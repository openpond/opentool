/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * Generated by: opentool/scripts/build-context.ts
 * Generated at: 2026-02-22T17:12:32.596Z
 *
 * This file contains bundled opentool documentation and source code
 * for use by AI code generators. It provides complete context about the opentool
 * framework without requiring runtime file system access.
 *
 * To regenerate: cd opentool && bun run scripts/build-context.ts
 * To use: Copy this file to your deployment system and import getOpenToolContext()
 */

export const OPENTOOL_VERSION = "0.8.24";

export const OPENTOOL_README = `# OpenTool

[![npm version](https://badge.fury.io/js/opentool.svg)](https://badge.fury.io/js/opentool)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

Build serverless TypeScript tools that work with AI assistants, handle crypto payments, and deploy to AWS Lambda automatically.

**For LLMs/AI Code Generation:** [\`context/opentool-context.ts\`](./context/opentool-context.ts)

## What is it?

OpenTool lets you write simple TypeScript functions that can be called by other agents, monetized with crypto payments, and deployed as serverless functions. It handles the boring stuff like:

Tools are either Public or Private. Public tools are accessible to the public and are monetized with crypto payments using x402. Private tools are accessible only to the app developer and are mainly for trading and onchain interaction use cases.

## Installation

\`\`\`bash
npm install opentool
\`\`\`

## Quick Start

### 1. Create a new project

\`\`\`bash
mkdir my-opentool-project
cd my-opentool-project
npm install opentool
npx opentool init
\`\`\`

### 2. Create your first tool

Create a \`tools/\` directory and add your first tool:

\`\`\`typescript
// tools/greet.ts
import { z } from "zod";

export const schema = z.object({
  name: z.string().describe("The name of the user to greet"),
});

export const metadata = {
  name: "greet",
  description: "Simple greeting tool",
};

export async function POST(request: Request) {
  const payload = await request.json();
  const { name } = schema.parse(payload);

  return Response.json({
    message: \`Hello, \${name}!\`,
  });
}
\`\`\`

### 3. Test locally

\`\`\`bash
# Validate your tools
npx opentool validate

# Start development server
npx opentool dev
\`\`\`

### Private tools: GET-only and POST-only

For private tools, say for internal trading apps:

- GET-only (scheduled default profile)
- POST-only (one-off, parameterized with Zod)
- \`profile.category\` defaults to \`tracker\` if omitted; set to \`strategy\` or \`orchestrator\` for PnL/automation tools.

GET-only (scheduled default)

\`\`\`typescript
// tools/aave-stake.ts
export const profile = {
  description: "Stake 100 USDC daily at 12:00 UTC",
  category: "strategy",
  schedule: { cron: "0 12 * * *", enabled: false },
};

export async function GET(_req: Request) {
  return Response.json({
    ok: true,
    action: "stake",
  });
}
\`\`\`

POST-only (one-off)

\`\`\`typescript
// tools/aave-unstake.ts
import { z } from "zod";

export const profile = {
  description: "Unstake USDC on demand",
  category: "tracker",
  notifyEmail: true,
};

export const schema = z.object({
  amount: z.string(),
  token: z.string().default("USDC"),
});

export async function POST(req: Request) {
  const body = await req.json();
  const { amount, token } = schema.parse(body);
  return Response.json({ ok: true, action: "unstake", amount, token });
}
\`\`\`

### Email notifications for one-off tools

- POST-only tools can set \`profile.notifyEmail = true\` to request an email when the tool runs.
- Scheduled tools should continue to use \`profile.schedule.notifyEmail\`.

### Cron schedules (\`profile.schedule\`)

- GET-only tools require \`profile.schedule\` with a standard 5‚Äì6 field cron expression (e.g., \`0 12 * * *\` or \`0 0 ? * MON-FRI *\`).
- Build validates the cron shape and emits \`dist/tools.json\` with schedule data per tool. Enabled defaults to \`false\` even if authors set it to \`true\` in code. Deployment targets can translate these cron strings to their provider format (e.g., EventBridge) downstream.
- Use \`profile.schedule.notifyEmail = true\` to request email delivery on schedule runs.

### Public tools: Add x402 payments (optional)

Protect your public tools with crypto payments using x402:

\`\`\`typescript
// tools/premium-report.ts
import { z } from "zod";
import { defineX402Payment } from "opentool/x402";

export const schema = z.object({
  symbol: z.string().describe("Crypto symbol (e.g., BTC)"),
});

export const payment = defineX402Payment({
  amount: "0.001",
  payTo: process.env.WALLET_ADDRESS!,
  currency: "USDC",
  network: "base-sepolia",
  message: "Premium analytics require payment",
});

export async function POST(request: Request) {
  const payload = await request.json();
  const { symbol } = schema.parse(payload);

  return Response.json({
    report: \`Premium analytics for \${symbol}\`,
  });
}
\`\`\`

Test the payment flow:

\`\`\`bash
# Start dev server
WALLET_ADDRESS=0x... npx opentool dev --input tools

# Test with the x402 client
PRIVATE_KEY=0x... bun examples/full-metadata/test-x402.ts
\`\`\`

Or test manually:

\`\`\`bash
# Get 402 response with payment requirements
curl -X POST http://localhost:7000/premium-report \\
  -H "content-type: application/json" \\
  -d '{"symbol":"BTC"}'

# Pay and retry with X-PAYMENT header (generated by x402 client)
curl -X POST http://localhost:7000/premium-report \\
  -H "content-type: application/json" \\
  -H "X-PAYMENT: \${X402_HEADER}" \\
  -d '{"symbol":"BTC"}'
\`\`\`

### MCP

By default, tools are HTTP-only. Want them accessible via MCP clients like Claude Desktop? Just add this to your tool file:

\`\`\`typescript
// tools/greet.ts
export const mcp = {
  enabled: true, // Now works with Claude Desktop, MCP Inspector, etc.
};
\`\`\`

Tools without this export stay HTTP-only, which is useful when you want selective access. Mix and match as needed.

### Testing with MCP Inspector

The \`examples/full-metadata\` project has an \`inspector.json\` config ready to go:

\`\`\`bash
cd examples/full-metadata
npx mcp-inspector --config inspector.json --server opentool-dev
\`\`\`

Copy \`.env.example\` to \`.env\` and add your credentials if you're using wallet/payment features. The inspector starts \`opentool dev\` automatically, so you only need one terminal. Only tools with \`mcp = { enabled: true }\` show up in the inspector - HTTP-only tools keep running on localhost.

### Quick x402 test with curl

1. Start the dev server against the example tools:

   \`\`\`bash
   npx opentool dev --input examples/full-metadata/tools
   \`\`\`

2. Trigger the paywall and inspect the returned payment requirements:

   \`\`\`bash
   curl -i \\
     -X POST http://localhost:7000/premium-report \\
     -H "content-type: application/json" \\
     -d '{"symbol":"BTC"}'
   \`\`\`

   The response includes a \`402 Payment Required\` status and JSON body with an \`x402.accepts[0]\` object describing the payment request.

3. Submit a follow-up request with an \`X-PAYMENT\` header produced by your x402 facilitator (for example, by using the Coinbase [x402](https://github.com/coinbase/x402) tooling or your own signing flow):

   \`\`\`bash
   curl -i \\
     -X POST http://localhost:7000/premium-report \\
     -H "content-type: application/json" \\
     -H "X-PAYMENT: \${X402_HEADER}" \\
     -d '{"symbol":"BTC"}'
   \`\`\`

   Replace \`\${X402_HEADER}\` with the base64-encoded payment payload returned by your facilitator‚Äôs \`/verify\` or \`/pay\` workflow. If the payment is valid the server responds with \`200 OK\`; otherwise it returns a new \`402\` with failure details.

### 5. Build for deployment

\`\`\`bash
# Build tools for Lambda deployment
npx opentool build
\`\`\`

### 6. Deploy to OpenPond

Create an account on [OpenPond](https://openpond.ai) and create a new project.

Add your project to the OpenPond project and connect it to your GitHub repository.

OpenPond will automatically detect the \`opentool\` dependency and deploy your tools to AWS Lambda.

## CLI Commands

### Build

Build your tools for deployment:

\`\`\`bash
npx opentool build [options]

Options:
  -i, --input <dir>      Input directory containing tools (default: "tools")
  -o, --output <dir>     Output directory for built tools (default: "dist")
  --name <name>          Server name (default: "opentool-server")
  --version <version>    Server version (default: "1.0.0")
\`\`\`

### Development Server

Start a local development server:

\`\`\`bash
npx opentool dev [options]

Options:
  -i, --input <dir>      Input directory containing tools (default: "tools")
  --watch                Watch for file changes (default: false)
\`\`\`

### Validate

Validate your tools:

\`\`\`bash
npx opentool validate [options]

Options:
  -i, --input <dir>      Input directory containing tools (default: "tools")
\`\`\`

### Generate Metadata

Generate \`metadata.json\` without building:

\`\`\`bash
npx opentool metadata [options]

Options:
  -i, --input <dir>      Input directory containing tools (default: "tools")
  -o, --output <file>    Output file path for metadata.json (default: "metadata.json")
  --name <name>          Server name (default: "opentool-server")
  --version <version>    Server version (default: "1.0.0")
\`\`\`

Generates the metadata file with tool schemas, payment configs, and discovery info. Useful for inspecting or sharing metadata without a full build.

## Tool Definition

Tools are just TypeScript files with a few exports:

\`\`\`typescript
import { z } from "zod";

// 1. Schema for input validation
export const schema = z.object({
  input: z.string().describe("Some input parameter"),
});

// 2. Metadata
export const metadata = {
  name: "my_tool",
  description: "What this tool does",
};

// 3. Optional: enable MCP mode
export const mcp = {
  enabled: true, // Makes it work with Claude Desktop, etc.
};

// 4. Handler (POST, GET, PUT, DELETE, etc.)
export async function POST(request: Request) {
  const payload = await request.json();
  const params = schema.parse(payload);

  // Your tool logic here
  return Response.json({
    result: "Tool response",
  });
}
\`\`\`

## Error Handling

Just return standard HTTP responses:

\`\`\`typescript
export async function POST(request: Request) {
  const payload = await request.json();
  const params = schema.parse(payload);

  if (someCondition) {
    return Response.json({ error: "Something went wrong" }, { status: 400 });
  }

  return Response.json({ result: "Success" });
}
\`\`\`

## Local Development

Run \`npx opentool dev\` to test your tools locally. It runs them via stdio (for MCP clients) or HTTP (for direct API calls). Good for:

- Testing tool logic
- Validating schemas
- Debugging before deployment

## Deployment

Push your repo to GitHub and connect it to [OpenPond](https://openpond.ai):

1. OpenPond detects the \`opentool\` dependency
2. Runs \`npx opentool build\`
3. Deploys to AWS Lambda with Function URLs
4. Done - your tools are live

## Examples

Check \`examples/full-metadata/\` for a complete example with payment and discovery features.

### Testing Examples Locally

\`\`\`bash
# Build and link the OpenTool package
npm run build
npm link

# Test the example
cd examples/full-metadata
npm link opentool
npm run build

# Check the output
cat dist/metadata.json

# Test the MCP server
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}' | node dist/mcp-server.js

# Or from repo root:
npm run examples:build      # Build example (CJS+ESM)
npm run examples:validate   # Validate metadata and tools
npm run examples:metadata   # Regenerate metadata.json
\`\`\`

## Metadata System

OpenTool has three levels of metadata config:

1. **Default** - pulls from your \`package.json\` automatically
2. **Project-level (optional)** - add a \`metadata.ts\` file for branding, payments, etc.
3. **Tool-level** - override metadata per tool

See [\`METADATA.md\`](./METADATA.md) for details on configuring metadata for on-chain registration and payments.

## What's Next

- Better watch mode that keeps metadata and tool artifacts synced during dev

## Contributing

Contributions welcome! See the [Contributing Guide](https://github.com/openpond/opentool/blob/master/CONTRIBUTING.md).

## License

MIT ¬© [OpenTool](https://opentool.dev)
`;

export const OPENTOOL_METADATA_GUIDE = `# OpenTool Metadata System

This guide explains how OpenTool's metadata system works, from simple automatic generation to full custom configuration for on-chain registration and payments.

## How It Works

OpenTool has a **three-tier metadata system** that gets progressively more sophisticated:

1. **üü¢ Automatic (Smart Defaults)** - Zero configuration required
2. **üî∏ Enhanced (metadata.ts)** - Custom configuration with smart fallbacks  
3. **üî¥ Full Control** - Complete tool-level overrides

The build process automatically generates a complete \`metadata.json\` file suitable for on-chain registration regardless of which tier you use.

## Tier 1: Smart Defaults (Zero Config)

For simple projects, OpenTool generates complete metadata automatically:

**What you provide:**
- \`package.json\` with basic fields
- Tool files in \`tools/\` directory

**What OpenTool generates automatically:**
\`\`\`json
{
  "metadataSpecVersion": "1.1.0",
  "name": "package-name",           // From package.json name
  "displayName": "Package Name",   // Formatted from name
  "version": "2.5.0",              // From package.json version (semantic string)
  "description": "...",            // From package.json description
  "author": "...",                 // From package.json author
  "repository": "...",             // From package.json repository
  "website": "...",                // From package.json homepage
  "category": "utility",           // Default fallback
  "termsOfService": "Please review terms before use.",
  "tools": [
    {
      "name": "filename",          // From .ts filename
      "description": "filename tool", // Auto-generated
      "inputSchema": { ... }       // From Zod schema
    }
  ]
}
\`\`\`

**Example project structure:**
\`\`\`
my-assistant/
‚îú‚îÄ‚îÄ package.json                 # Basic npm package info
‚îî‚îÄ‚îÄ tools/
    ‚îî‚îÄ‚îÄ greeting.ts              # Tool with schema and POST handler
\`\`\`

## Tier 2: Enhanced Metadata (metadata.ts, optional)

Add a \`metadata.ts\` file to customize agent-wide settings while keeping smart defaults for missing fields:

\`\`\`typescript
export const metadata = {
  // Override smart defaults
  displayName: "My AI Assistant Pro",
  category: "productivity",
  
  // Add discovery fields  
  keywords: ["ai", "assistant", "productivity"],
  useCases: ["Customer support", "Content writing"],
  
  // Add payment configuration
  payment: {
    amountUSDC: 0.01,
    description: "Standard usage tier",
    x402: true,
    openpondDirect: true,
    acceptedMethods: ["USDC", "ETH"],
    chains: [8453] // Base
  },
  
  // Smart defaults still apply for: name, version, description, author, etc.
};
\`\`\`

The build process **merges** your metadata with smart defaults, so you only specify what you want to customize.

If \`metadata.ts\` is missing, OpenTool uses smart defaults from \`package.json\` and folder name without failing the build.

## Tier 3: Full Tool-Level Control

Individual tools can override agent defaults and add rich discovery metadata:

\`\`\`typescript
// tools/analyze.ts
import { z } from "zod";

export const schema = z.object({
  text: z.string().describe("Text to analyze")
});

export const metadata = {
  name: "text-analyzer",
  description: "Advanced text analysis with sentiment and keywords",
  
  // Override agent-level payment
  payment: {
    amountUSDC: 0.05,  // More expensive than agent default
    acceptETH: true,
    acceptSolana: true,
    acceptX402: true,
    chains: [8453]
  },
  
  // MCP annotations for behavior hints
  annotations: {
    readOnlyHint: true,     // Safe, only reads data
    idempotentHint: true,   // Same input = same output
  },
  
  // Rich discovery metadata
  discovery: {
    keywords: ["nlp", "sentiment", "analysis"],
    category: "ai-processing",
    examples: [
      {
        description: "Analyze customer feedback",
        input: { text: "This product is amazing!" },
        expectedOutput: "Sentiment: positive (0.9), Keywords: product, amazing"
      }
    ],
    performance: {
      estimatedDuration: 2000,
      isAsync: true
    },
    safety: {
      requiresConfirmation: false,
      isReversible: true,
      sideEffects: []
    }
  }
};

export async function POST(request: Request) {
  const payload = await request.json();
  const params = schema.parse(payload);

  // Implementation
  return Response.json({
    result: "Analysis complete",
  });
}
\`\`\`

## Build Process Flow

When you run \`opentool build\`, here's what happens:

1. **üìÇ Scan** \`tools/\` directory for \`.ts\`/\`.js\` files
2. **üîç Load** optional \`metadata.ts\` (or \`discovery.ts\` for backwards compatibility)
3. **üì¶ Read** \`package.json\` for fallback values
4. **üß† Generate** smart defaults from folder name if needed
5. **‚öôÔ∏è Compile** TypeScript tools to JavaScript
6. **üîó Merge** all metadata layers:
   - Tool metadata (highest priority)
   - Agent metadata from metadata.ts
   - Smart defaults from package.json
   - Built-in fallbacks (lowest priority)
7. **üìÑ Generate** complete \`metadata.json\`

## Metadata Hierarchy

The system uses this precedence order (highest to lowest):

\`\`\`
Tool-level metadata (in tool files)
     ‚Üì overrides
Agent-level metadata (metadata.ts) 
     ‚Üì overrides
Smart defaults (package.json + folder name)
     ‚Üì overrides
Built-in fallbacks (sensible defaults)
\`\`\`

## Payment Configuration

Payment settings work hierarchically:

\`\`\`typescript
// Agent-level default (metadata.ts)
export const metadata = {
  payment: {
    amountUSDC: 0.01,        // Default for all tools
    acceptETH: true,
    acceptSolana: true,
    acceptX402: true,
    chains: [8453]
  }
};

// Tool-level override (tools/premium.ts)
export const metadata = {
  payment: {
    amountUSDC: 0.10,        // Override: more expensive
    x402: true,
    openpondDirect: true,
    acceptedMethods: ["USDC"],
    chains: [8453]
  }
};
\`\`\`

**Payment Settings:**
- **acceptedMethods**: Currency codes accepted for settlement (e.g. \`USDC\`, \`ETH\`)
- **x402**: Enables HTTP 402 (paywall) flows
- **openpondDirect**: Enables direct settlement through OpenPond
- **chains**: Supported blockchain networks (accepts numbers like \`8453\` or strings like \`"base"\`)

## Blockchain Networks (Chains)

Specify which blockchain networks your agent/tools interact with using the \`chains\` field:

\`\`\`typescript
// Agent-level chains (metadata.ts)
export const metadata = {
  displayName: "Multi-Chain Trading Bot",

  // Chains accepts numbers (EVM chain IDs) or strings (chain names)
  chains: [
    1,                  // Ethereum mainnet (EVM chain ID)
    8453,               // Base (EVM chain ID)
    "base-sepolia",     // Base testnet (Alchemy naming)
    "solana",           // Solana (chain name)
    "hyperliquid"       // Hyperliquid (chain name)
  ]
};

// Tool-level override (tools/ethereum-swap.ts)
export const metadata = {
  name: "ethereum-swap",
  chains: [1, "ethereum"]  // Only Ethereum for this tool
};
\`\`\`

**Chain Format:**
- **Numbers**: EVM chain IDs (e.g., \`1\`=Ethereum, \`8453\`=Base, \`42161\`=Arbitrum)
- **Strings**: Chain names following Alchemy naming conventions (e.g., \`"base-sepolia"\`, \`"solana"\`, \`"hyperliquid"\`)

**Common Chain IDs:**
- Ethereum: \`1\`
- Base: \`8453\`
- Arbitrum: \`42161\`
- Polygon: \`137\`
- Optimism: \`10\`

**Hierarchy:**
- Tools inherit agent-level chains by default
- Tool-level chains override agent chains for that specific tool
- Used for discovery, filtering, and showing network-specific UI

## Generated Metadata JSON

The final \`metadata.json\` combines all metadata into a standardized format:

\`\`\`json
{
  "metadataSpecVersion": "1.1.0",
  "name": "my-assistant",
  "displayName": "My AI Assistant Pro",
  "version": "2.5.0",
  "description": "A helpful AI assistant for productivity tasks",
  "author": "Jane Developer",
  "repository": "https://github.com/jane/my-ai-assistant",
  "website": "https://my-ai-assistant.com",
  "category": "productivity",
  "termsOfService": "Please review terms before use.",
  "chains": [8453, "base-sepolia"],

  "tools": [
    {
      "name": "text-analyzer",
      "description": "Advanced text analysis with sentiment and keywords",
      "inputSchema": { /* JSON Schema from Zod */ },
      "payment": { /* Tool-specific payment config */ },
      "annotations": { /* MCP behavior hints */ },
      "discovery": { /* SEO and discovery metadata */ },
      "chains": [8453, "base-sepolia"]
    }
  ],

  "payment": { /* Agent-level payment defaults */ },
  "discovery": { /* Agent-level discovery metadata */ }
}
\`\`\`

## Best Practices

### üü¢ Start Simple
Begin with just \`package.json\` and tool files. OpenTool handles the rest automatically.

### üî∏ Add Metadata When Needed
Create \`metadata.ts\` only when you need:
- Custom branding (displayName, category)
- Payment configuration
- Discovery/SEO optimization

### üî¥ Tool-Level Overrides Sparingly
Use tool-level metadata for:
- Different pricing tiers
- Tool-specific behavior hints
- Rich examples and documentation

### üí∞ Pricing Guidelines
- **Free/Demo**: \`amountUSDC: 0\`
- **Simple Operations**: \`0.001 - 0.01 USDC\`
- **Complex Processing**: \`0.01 - 0.1 USDC\`  
- **Premium Features**: \`0.1+ USDC\`

### üîí Safety Annotations
Always set accurate MCP annotations:
- \`readOnlyHint: true\` for data-reading tools
- \`destructiveHint: true\` for irreversible operations
- \`idempotentHint: true\` if same input always gives same result

## On-Chain Registration

The generated \`metadata.json\` enables decentralized discovery:

1. **Deploy** your agent to AWS Lambda or supported platform
2. **Register** on-chain through the wallet UI
3. **Discover** agents are indexed by category, keywords, and capabilities
4. **Payments** are automatically processed through configured methods

## Example Projects

See \`examples/full-metadata\` for a full configuration that demonstrates agent metadata, tool-level overrides, and the dual-module build outputs.
`;

export const OPENTOOL_WALLET_SOURCE: Record<string, string> = {
  "src/wallet/env.ts": `export type TurnkeyEnvConfig = {
  organizationId: string;
  apiPublicKey: string;
  apiPrivateKey: string;
  signWith: string;
  apiBaseUrl?: string;
};

function readTrimmed(name: string): string | undefined {
  const value = process.env[name];
  const trimmed = typeof value === "string" ? value.trim() : "";
  return trimmed.length ? trimmed : undefined;
}

/**
 * Reads Turnkey configuration from environment variables.
 */
export function readTurnkeyEnv(): TurnkeyEnvConfig | undefined {
  const suborgId = readTrimmed("TURNKEY_SUBORG_ID");
  if (!suborgId) return undefined;

  const apiPublicKey = readTrimmed("TURNKEY_API_PUBLIC_KEY");
  const apiPrivateKey = readTrimmed("TURNKEY_API_PRIVATE_KEY");
  const signWith = readTrimmed("TURNKEY_WALLET_ADDRESS");
  if (!apiPublicKey || !apiPrivateKey || !signWith) return undefined;

  const apiBaseUrl = readTrimmed("TURNKEY_API_BASE_URL");

  return {
    organizationId: suborgId,
    apiPublicKey,
    apiPrivateKey,
    signWith,
    ...(apiBaseUrl ? { apiBaseUrl } : {}),
  };
}
`,
  "src/wallet/constants.ts": `import { zeroAddress } from "viem";
import {
  arbitrum,
  arbitrumSepolia,
  base,
  baseSepolia,
  mainnet,
} from "viem/chains";

import type {
  ChainMetadata,
  ChainTokenMap,
  HexAddress,
  RpcUrlResolver,
  WalletRegistry,
} from "./types";

const BASE_ALCHEMY_HOST = "https://base-mainnet.g.alchemy.com/v2/";
const ETHEREUM_ALCHEMY_HOST = "https://eth-mainnet.g.alchemy.com/v2/";
const BASE_SEPOLIA_ALCHEMY_HOST = "https://base-sepolia.g.alchemy.com/v2/";
const ARBITRUM_ALCHEMY_HOST = "https://arb-mainnet.g.alchemy.com/v2/";
const ARBITRUM_SEPOLIA_ALCHEMY_HOST = "https://arb-sepolia.g.alchemy.com/v2/";

function buildRpcResolver(
  host: string,
  fallbackUrls: readonly string[]
): RpcUrlResolver {
  return (options) => {
    if (options?.url) {
      return options.url;
    }

    if (options?.apiKey) {
      return \`\${host}\${options.apiKey}\`;
    }

    if (fallbackUrls.length > 0) {
      return fallbackUrls[0];
    }

    throw new Error(
      "No RPC URL available: supply a full url via options or an apiKey for the default host"
    );
  };
}

const chains: Record<string, ChainMetadata> = {
  base: {
    id: base.id,
    slug: "base",
    name: "Base",
    chain: base,
    rpcUrl: buildRpcResolver(BASE_ALCHEMY_HOST, base.rpcUrls.default.http),
    publicRpcUrls: base.rpcUrls.default.http,
  },
  ethereum: {
    id: mainnet.id,
    slug: "ethereum",
    name: "Ethereum",
    chain: mainnet,
    rpcUrl: buildRpcResolver(
      ETHEREUM_ALCHEMY_HOST,
      mainnet.rpcUrls.default.http
    ),
    publicRpcUrls: mainnet.rpcUrls.default.http,
  },
  baseSepolia: {
    id: baseSepolia.id,
    slug: "base-sepolia",
    name: "Base Sepolia",
    chain: baseSepolia,
    rpcUrl: buildRpcResolver(
      BASE_SEPOLIA_ALCHEMY_HOST,
      baseSepolia.rpcUrls.default.http
    ),
  },
  arbitrum: {
    id: arbitrum.id,
    slug: "arbitrum",
    name: "Arbitrum One",
    chain: arbitrum,
    rpcUrl: buildRpcResolver(
      ARBITRUM_ALCHEMY_HOST,
      arbitrum.rpcUrls.default.http
    ),
    publicRpcUrls: arbitrum.rpcUrls.default.http,
  },
  arbitrumSepolia: {
    id: arbitrumSepolia.id,
    slug: "arbitrum-sepolia",
    name: "Arbitrum Sepolia",
    chain: arbitrumSepolia,
    rpcUrl: buildRpcResolver(
      ARBITRUM_SEPOLIA_ALCHEMY_HOST,
      arbitrumSepolia.rpcUrls.default.http
    ),
    publicRpcUrls: arbitrumSepolia.rpcUrls.default.http,
  },
};

function createNativeToken(
  chainId: number,
  symbol: string,
  name: string
): ChainTokenMap {
  return {
    [symbol]: {
      symbol,
      name,
      decimals: 18,
      address: zeroAddress,
      chainId,
      isNative: true,
    },
  };
}

function token(
  chainId: number,
  symbol: string,
  name: string,
  address: HexAddress,
  decimals: number
) {
  return {
    symbol,
    name,
    decimals,
    address,
    chainId,
  };
}

const tokens: Record<string, ChainTokenMap> = {
  base: {
    ...createNativeToken(base.id, "ETH", "Ether"),
    USDC: token(
      base.id,
      "USDC",
      "USD Coin",
      "0x833589fCD6eDb6E08f4c7C31c9A8Ba32D74b86B2",
      6
    ),
  },
  ethereum: {
    ...createNativeToken(mainnet.id, "ETH", "Ether"),
    USDC: token(
      mainnet.id,
      "USDC",
      "USD Coin",
      "0xA0b86991c6218b36c1d19d4a2e9Eb0cE3606eB48",
      6
    ),
  },
  arbitrum: {
    ...createNativeToken(arbitrum.id, "ETH", "Ether"),
    USDC: token(
      arbitrum.id,
      "USDC",
      "USD Coin",
      "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
      6
    ),
  },
  arbitrumSepolia: {
    ...createNativeToken(arbitrumSepolia.id, "ETH", "Ether"),
    USDC: token(
      arbitrumSepolia.id,
      "USDC",
      "USD Coin",
      "0x1baAbB04529D43a73232B713C0FE471f7c7334d5",
      6
    ),
  },
};

export const DEFAULT_CHAIN = chains.base;
export const DEFAULT_TOKENS = tokens.base;

export const registry: WalletRegistry = {
  chains,
  tokens,
};

export { chains, tokens };
`,
  "src/wallet/index.ts": `export * from "./types";
export { chains, tokens, registry, DEFAULT_CHAIN, DEFAULT_TOKENS } from "./constants";

import { createPublicClient, http } from "viem";

import type {
  RpcProviderOptions,
  WalletContext,
  WalletFullContext,
  WalletReadonlyContext,
  WalletOptions,
  WalletProviderType,
  WalletPrivateKeyOptions,
  WalletTurnkeyOptions,
  WalletReadonlyOptions,
} from "./types";
import {
  chains as chainRegistry,
  tokens as tokenRegistry,
  registry as walletRegistry,
  DEFAULT_CHAIN,
  DEFAULT_TOKENS,
} from "./constants";
import { createPrivateKeyProvider } from "./providers/private-key";
import { createTurnkeyProvider } from "./providers/turnkey";
import { readTurnkeyEnv } from "./env";

type ChainSlug = keyof typeof chainRegistry;

function resolveChainSlug(reference?: string | number): ChainSlug {
  if (reference === undefined) {
    return (Object.entries(chainRegistry).find(([, meta]) => meta.id === DEFAULT_CHAIN.id)?.[0] ||
      DEFAULT_CHAIN.slug) as ChainSlug;
  }

  if (typeof reference === "number") {
    const match = Object.entries(chainRegistry).find(([, meta]) => meta.id === reference);
    if (match) {
      return match[0] as ChainSlug;
    }
  } else if (typeof reference === "string") {
    const sanitize = (value: string) => value.toLowerCase().replace(/[^a-z0-9]/g, "");

    if (reference in chainRegistry) {
      return reference as ChainSlug;
    }

    const normalized = sanitize(reference);

    const keyMatch = Object.entries(chainRegistry).find(([key]) => sanitize(key) === normalized);
    if (keyMatch) {
      return keyMatch[0] as ChainSlug;
    }

    const slugMatch = Object.entries(chainRegistry).find(([, meta]) => {
      return meta.slug && sanitize(meta.slug) === normalized;
    });
    if (slugMatch) {
      return slugMatch[0] as ChainSlug;
    }

    const asNumber = Number.parseInt(normalized, 10);
    if (!Number.isNaN(asNumber)) {
      const match = Object.entries(chainRegistry).find(([, meta]) => meta.id === asNumber);
      if (match) {
        return match[0] as ChainSlug;
      }
    }
  }

  throw new Error(\`Unknown chain reference: \${reference}\`);
}

export function getRpcUrl(chain: ChainSlug | number, options?: RpcProviderOptions): string {
  const slug = resolveChainSlug(chain);
  const entry = chainRegistry[slug];
  return entry.rpcUrl(options);
}

export function wallet(options: WalletPrivateKeyOptions): Promise<WalletFullContext>;
export function wallet(options: WalletTurnkeyOptions): Promise<WalletFullContext>;
export function wallet(options?: WalletReadonlyOptions): Promise<WalletReadonlyContext>;
export async function wallet(options: WalletOptions = {}): Promise<WalletContext> {
  const envPrivateKey = process.env.PRIVATE_KEY?.trim();
  const envTurnkey = readTurnkeyEnv();

  const effectivePrivateKey = options.privateKey ?? envPrivateKey;
  const effectiveTurnkey = options.turnkey ?? envTurnkey;

  if (effectivePrivateKey && effectiveTurnkey) {
    throw new Error("wallet() cannot be initialized with both privateKey and turnkey credentials");
  }

  const slug = resolveChainSlug(options.chain);
  const chain = chainRegistry[slug];
  const tokens = tokenRegistry[slug] ?? {};
  const overrides: RpcProviderOptions = {};
  const envRpcUrl = process.env.RPC_URL?.trim();
  const envApiKey = process.env.ALCHEMY_API_KEY?.trim();
  if (options.rpcUrl ?? envRpcUrl) {
    overrides.url = (options.rpcUrl ?? envRpcUrl)!;
  }
  if (options.apiKey ?? envApiKey) {
    overrides.apiKey = (options.apiKey ?? envApiKey)!;
  }

  const rpcUrl = getRpcUrl(slug, overrides);

  let providerType: WalletProviderType = "readonly";
  let signerProvider:
    | ReturnType<typeof createPrivateKeyProvider>
    | (Awaited<ReturnType<typeof createTurnkeyProvider>>)
    | undefined;

  if (effectivePrivateKey) {
    signerProvider = createPrivateKeyProvider({
      chain,
      rpcUrl,
      privateKey: effectivePrivateKey,
    });
    providerType = "privateKey";
  } else if (effectiveTurnkey) {
    const turnkeyConfig = {
      chain,
      rpcUrl,
      organizationId: effectiveTurnkey.organizationId,
      apiPublicKey: effectiveTurnkey.apiPublicKey,
      apiPrivateKey: effectiveTurnkey.apiPrivateKey,
      signWith: effectiveTurnkey.signWith,
    } as Parameters<typeof createTurnkeyProvider>[0];

    if (effectiveTurnkey.apiBaseUrl) {
      turnkeyConfig.apiBaseUrl = effectiveTurnkey.apiBaseUrl;
    }

    signerProvider = await createTurnkeyProvider(turnkeyConfig);
    providerType = "turnkey";
  }

  const publicClient = signerProvider?.publicClient ??
    createPublicClient({
      chain: chain.chain,
      transport: http(rpcUrl),
    });

  const baseContext = {
    chain,
    tokens,
    rpcUrl,
    providerType,
    publicClient,
    getRpcUrl: (override?: RpcProviderOptions) => getRpcUrl(slug, override),
    ...(signerProvider ? { address: signerProvider.address } : {}),
  } satisfies WalletReadonlyContext;

  if (signerProvider) {
    const { publicClient: _ignored, ...rest } = signerProvider;
    return {
      ...baseContext,
      ...rest,
    } as WalletFullContext;
  }

  return baseContext;
}

export const walletToolkit = {
  chains: chainRegistry,
  tokens: tokenRegistry,
  registry: walletRegistry,
  defaults: {
    chain: DEFAULT_CHAIN,
    tokens: DEFAULT_TOKENS,
  },
  getRpcUrl,
  wallet,
} as const;
`,
  "src/wallet/providers/turnkey.ts": `import { Turnkey } from "@turnkey/sdk-server";
import { createAccount } from "@turnkey/viem";
import {
  createPublicClient,
  createWalletClient,
  http,
  type Chain,
  type PublicClient,
  type Transport,
} from "viem";
import type { Account } from "viem/accounts";

import type {
  ChainMetadata,
  HexAddress,
  TurnkeySignWith,
  WalletSignerContext,
  WalletSendTransactionParams,
  WalletTransferParams,
} from "../types";

export interface TurnkeyProviderConfig {
  chain: ChainMetadata;
  rpcUrl: string;
  organizationId: string;
  apiPublicKey: string;
  apiPrivateKey: string;
  signWith: TurnkeySignWith;
  apiBaseUrl?: string;
}

export interface TurnkeyProviderResult extends WalletSignerContext {
  publicClient: PublicClient<Transport, Chain>;
}

function createNonceSource(start: number = Date.now()) {
  let last = start;
  return () => {
    const now = Date.now();
    if (now > last) {
      last = now;
    } else {
      last += 1;
    }
    return last;
  };
}

export async function createTurnkeyProvider(
  config: TurnkeyProviderConfig
): Promise<TurnkeyProviderResult> {
  const turnkey = new Turnkey({
    apiBaseUrl: config.apiBaseUrl ?? "https://api.turnkey.com",
    // The delegated sub-organization the API key pair belongs to.
    defaultOrganizationId: config.organizationId,
    apiPublicKey: config.apiPublicKey,
    apiPrivateKey: config.apiPrivateKey,
  });

  const account = (await createAccount({
    client: turnkey.apiClient(),
    organizationId: config.organizationId,
    signWith: config.signWith,
  })) as Account;

  const transport = http(config.rpcUrl);
  const publicClient = createPublicClient<Transport, Chain>({
    chain: config.chain.chain,
    transport,
  });

  const walletClient = createWalletClient<Transport, Chain, Account>({
    account,
    chain: config.chain.chain,
    transport,
  });

  async function sendTransaction(params: WalletSendTransactionParams) {
    const tx: any = {
      account,
    };
    if (params.to) {
      tx.to = params.to;
    }
    if (params.value !== undefined) {
      tx.value = params.value;
    }
    if (params.data !== undefined) {
      tx.data = params.data;
    }

    return walletClient.sendTransaction(tx);
  }

  async function getNativeBalance() {
    return publicClient.getBalance({ address: account.address });
  }

  async function transfer(params: WalletTransferParams) {
    return sendTransaction({
      to: params.to,
      value: params.amount,
      ...(params.data !== undefined ? { data: params.data } : {}),
    });
  }

  return {
    address: account.address as HexAddress,
    account,
    walletClient,
    publicClient,
    sendTransaction,
    getNativeBalance,
    transfer,
    nonceSource: createNonceSource(),
  };
}
`,
  "src/wallet/providers/private-key.ts": `import { createPublicClient, createWalletClient, http, type Chain, type PublicClient, type Transport } from "viem";
import { privateKeyToAccount, type Account } from "viem/accounts";

import type {
  ChainMetadata,
  HexAddress,
  WalletSignerContext,
  WalletSendTransactionParams,
  WalletTransferParams,
} from "../types";

function normalizePrivateKey(raw: string): \`0x\${string}\` {
  const trimmed = raw.trim();
  const withPrefix = trimmed.startsWith("0x") ? trimmed : \`0x\${trimmed}\`;
  if (!/^0x[0-9a-fA-F]{64}$/.test(withPrefix)) {
    throw new Error("wallet() privateKey must be a 32-byte hex string");
  }
  return withPrefix as \`0x\${string}\`;
}

export interface PrivateKeyProviderConfig {
  chain: ChainMetadata;
  rpcUrl: string;
  privateKey: string;
}

export interface PrivateKeyProviderResult extends WalletSignerContext {
  publicClient: PublicClient<Transport, Chain>;
}

function createNonceSource(start: number = Date.now()) {
  let last = start;
  return () => {
    const now = Date.now();
    if (now > last) {
      last = now;
    } else {
      last += 1;
    }
    return last;
  };
}

export function createPrivateKeyProvider(
  config: PrivateKeyProviderConfig
): PrivateKeyProviderResult {
  const privateKey = normalizePrivateKey(config.privateKey);
  const account = privateKeyToAccount(privateKey);

  const transport = http(config.rpcUrl);
  const publicClient = createPublicClient<Transport, Chain>({
    chain: config.chain.chain,
    transport,
  });

  const walletClient = createWalletClient<Transport, Chain, Account>({
    account,
    chain: config.chain.chain,
    transport,
  });

  async function sendTransaction(params: WalletSendTransactionParams) {
    const tx: any = {
      account,
    };
    if (params.to) {
      tx.to = params.to;
    }
    if (params.value !== undefined) {
      tx.value = params.value;
    }
    if (params.data !== undefined) {
      tx.data = params.data;
    }

    return walletClient.sendTransaction(tx);
  }

  async function getNativeBalance() {
    return publicClient.getBalance({ address: account.address });
  }

  async function transfer(params: WalletTransferParams) {
    return sendTransaction({
      to: params.to,
      value: params.amount,
      ...(params.data !== undefined ? { data: params.data } : {}),
    });
  }

  return {
    address: account.address as HexAddress,
    account,
    walletClient,
    publicClient,
    sendTransaction,
    getNativeBalance,
    transfer,
    nonceSource: createNonceSource(),
  };
}
`,
  "src/wallet/turnkey.ts": `export interface TurnkeyCredentials {
  organizationId: string;
  apiPublicKey: string;
  apiPrivateKey: string;
  apiBaseUrl?: string;
}

export interface TurnkeyWalletConfig extends TurnkeyCredentials {
  walletId?: string;
}

// Placeholder implementation to be replaced in the wallet integration work.
export function createTurnkeyWalletClient(_config: TurnkeyWalletConfig) {
  throw new Error("Turnkey wallet support is not implemented yet");
}
`,
  "src/wallet/types.ts": `import type { Chain, PublicClient, Transport, WalletClient } from "viem";
import type { Account } from "viem/accounts";

export type Hex = \`0x\${string}\`;
export type HexAddress = \`0x\${string}\`;

export interface RpcProviderOptions {
  /** Optional fully-qualified RPC URL override. */
  url?: string;
  /** Provider API key to interpolate into hosted RPC templates. */
  apiKey?: string;
}

export type RpcUrlResolver = (options?: RpcProviderOptions) => string;

export interface ChainMetadata {
  id: number;
  slug: string;
  name: string;
  chain: Chain;
  rpcUrl: RpcUrlResolver;
  publicRpcUrls?: readonly string[];
}

export interface TokenMetadata {
  symbol: string;
  name: string;
  decimals: number;
  address: HexAddress;
  chainId: number;
  isNative?: boolean;
}

export type ChainTokenMap = Record<string, TokenMetadata>;

export interface WalletRegistry {
  chains: Record<string, ChainMetadata>;
  tokens: Record<string, ChainTokenMap>;
}

export type ChainReference = string | number;

export type WalletProviderType = "readonly" | "privateKey" | "turnkey";

export type TurnkeySignWith = string;

export interface TurnkeyOptions {
  organizationId: string;
  apiPublicKey: string;
  apiPrivateKey: string;
  /** Identifier of the delegated signer (Turnkey address or private key ID). */
  signWith: TurnkeySignWith;
  apiBaseUrl?: string;
}

export interface WalletOptionsBase {
  chain?: ChainReference;
  apiKey?: string;
  rpcUrl?: string;
}

export interface WalletPrivateKeyOptions extends WalletOptionsBase {
  privateKey: string;
  turnkey?: undefined;
}

export interface WalletTurnkeyOptions extends WalletOptionsBase {
  privateKey?: undefined;
  turnkey: TurnkeyOptions;
}

export type WalletReadonlyOptions = WalletOptionsBase & {
  privateKey?: undefined;
  turnkey?: undefined;
};

export type WalletOptions =
  | WalletReadonlyOptions
  | WalletPrivateKeyOptions
  | WalletTurnkeyOptions;

export interface WalletSendTransactionParams {
  to?: HexAddress;
  value?: bigint;
  data?: Hex;
}

export interface WalletTransferParams {
  to: HexAddress;
  amount: bigint;
  data?: Hex;
}

export interface WalletSignerContext {
  address: HexAddress;
  account: Account;
  walletClient: WalletClient<Transport, Chain, Account>;
  publicClient: PublicClient<Transport, Chain>;
  sendTransaction(params: WalletSendTransactionParams): Promise<Hex>;
  getNativeBalance(): Promise<bigint>;
  transfer(params: WalletTransferParams): Promise<Hex>;
  /**
   * Optional monotonic nonce provider for systems that require client-side nonces.
   */
  nonceSource?: () => number;
}

export interface WalletBaseContext {
  chain: ChainMetadata;
  rpcUrl: string;
  tokens: ChainTokenMap;
  providerType: WalletProviderType;
  publicClient: PublicClient;
  getRpcUrl(options?: RpcProviderOptions): string;
  /** Address is present when a signer is configured; undefined for read-only wallets. */
  address?: HexAddress;
}

export type WalletReadonlyContext = WalletBaseContext;
export type WalletFullContext = WalletBaseContext & WalletSignerContext;
export type WalletContext = WalletReadonlyContext | WalletFullContext;
`,
};

/**
 * Get formatted context prompt for AI code generation
 *
 * This function returns a comprehensive prompt containing all opentool
 * documentation and source code that an AI model
 * should use as authoritative reference when generating opentool code.
 */
export function getOpenToolContext(): string {
  const sections: string[] = [];

  sections.push("# OPENTOOL FRAMEWORK - COMPLETE DOCUMENTATION AND SOURCE");
  sections.push("");
  sections.push("You have access to the complete opentool v" + OPENTOOL_VERSION + " framework.");
  sections.push("This includes documentation and source code.");
  sections.push("Use these as your AUTHORITATIVE reference. Follow the patterns EXACTLY.");
  sections.push("");

  sections.push("## README.md - Framework Overview");
  sections.push("");
  sections.push(OPENTOOL_README);
  sections.push("");

  sections.push("## METADATA.md - Metadata and Payment System");
  sections.push("");
  sections.push(OPENTOOL_METADATA_GUIDE);
  sections.push("");


  sections.push("## WALLET API SOURCE CODE");
  sections.push("");
  sections.push("Complete wallet implementation showing exact function signatures, types, and usage.");
  sections.push("THIS IS THE AUTHORITATIVE API - use exactly as shown here.");
  sections.push("");

  for (const [filename, content] of Object.entries(OPENTOOL_WALLET_SOURCE)) {
    sections.push(`### ${filename}`);
    sections.push("\`\`\`typescript");
    sections.push(content);
    sections.push("\`\`\`");
    sections.push("");
  }

  sections.push("## KEY PATTERNS TO FOLLOW");
  sections.push("");
  sections.push("### Wallet Usage (CORRECT):");
  sections.push("\`\`\`typescript");
  sections.push("import { wallet } from 'opentool/wallet';");
  sections.push("");
  sections.push("const context = await wallet({");
  sections.push("  chain: 'base-sepolia',");
  sections.push("  apiKey: process.env.ALCHEMY_API_KEY,");
  sections.push("  turnkey: {");
  sections.push("    organizationId: process.env.TURNKEY_SUBORG_ID!,");
  sections.push("    apiPublicKey: process.env.TURNKEY_API_PUBLIC_KEY!,");
  sections.push("    apiPrivateKey: process.env.TURNKEY_API_PRIVATE_KEY!,");
  sections.push("    signWith: process.env.TURNKEY_WALLET_ADDRESS as `0x${string}`,");
  sections.push("  },");
  sections.push("});");
  sections.push("");
  sections.push("const balance = await context.getNativeBalance();");
  sections.push("const txHash = await context.transfer({ to, amount });");
  sections.push("\`\`\`");
  sections.push("");
  sections.push("### HTTP Handler Pattern:");
  sections.push("\`\`\`typescript");
  sections.push("import { z } from 'zod';");
  sections.push("");
  sections.push("export const schema = z.object({");
  sections.push("  // input parameters");
  sections.push("});");
  sections.push("");
  sections.push("export const metadata = {");
  sections.push("  name: 'tool-name',");
  sections.push("  description: 'Tool description',");
  sections.push("};");
  sections.push("");
  sections.push("export async function POST(request: Request) {");
  sections.push("  const payload = await request.json();");
  sections.push("  const params = schema.parse(payload);");
  sections.push("  ");
  sections.push("  // implement tool logic");
  sections.push("  ");
  sections.push("  return Response.json({ result: 'success' });");
  sections.push("}");
  sections.push("\`\`\`");
  sections.push("");

  return sections.join("\n");
}
