/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * Generated by: opentool/scripts/build-context.ts
 * Generated at: 2025-11-23T14:26:31.219Z
 *
 * This file contains bundled opentool documentation, examples, and source code
 * for use by AI code generators. It provides complete context about the opentool
 * framework without requiring runtime file system access.
 *
 * To regenerate: cd opentool && bun run scripts/build-context.ts
 * To use: Copy this file to your deployment system and import getOpenToolContext()
 */

export const OPENTOOL_VERSION = "0.7.12";

export const OPENTOOL_README = `# OpenTool

[![npm version](https://badge.fury.io/js/opentool.svg)](https://badge.fury.io/js/opentool)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

Build serverless TypeScript tools that work with AI assistants, handle crypto payments, and deploy to AWS Lambda automatically.

**For LLMs/AI Code Generation:** [\`context/opentool-context.ts\`](./context/opentool-context.ts)

## What is it?

OpenTool lets you write simple TypeScript functions that can be called by other agents, monetized with crypto payments, and deployed as serverless functions. It handles the boring stuff like:

Tools are either Public or Private. Public tools are accessible to the public and are monetized with crypto payments using x402. Private tools are accessible only to the app developer and are mainly for trading and onchain interaction use cases.

## Installation

\`\`\`bash
npm install opentool
\`\`\`

## Quick Start

### 1. Create a new project

\`\`\`bash
mkdir my-opentool-project
cd my-opentool-project
npm init -y
npm install opentool
\`\`\`

### 2. Create your first tool

Create a \`tools/\` directory and add your first tool:

\`\`\`typescript
// tools/greet.ts
import { z } from "zod";

export const schema = z.object({
  name: z.string().describe("The name of the user to greet"),
});

export const metadata = {
  name: "greet",
  description: "Simple greeting tool",
};

export async function POST(request: Request) {
  const payload = await request.json();
  const { name } = schema.parse(payload);

  return Response.json({
    message: \`Hello, \${name}!\`,
  });
}
\`\`\`

### 3. Test locally

\`\`\`bash
# Validate your tools
npx opentool validate

# Start development server
npx opentool dev
\`\`\`

### Private tools: GET-only and POST-only

For private tools, say for internal trading apps:

- GET-only (scheduled default profile)
- POST-only (one-off, parameterized with Zod)

GET-only (scheduled default)

\`\`\`typescript
// tools/aave-stake.ts
export const profile = {
  description: "Stake 100 USDC daily at 12:00 UTC",
  fixedAmount: "100",
  tokenSymbol: "USDC",
  schedule: { cron: "0 12 * * *", enabled: false },
  limits: { concurrency: 1, dailyCap: 1 },
};

export async function GET(_req: Request) {
  const amount = profile.fixedAmount;
  return Response.json({
    ok: true,
    action: "stake",
    amount,
    token: profile.tokenSymbol,
  });
}
\`\`\`

POST-only (one-off)

\`\`\`typescript
// tools/aave-unstake.ts
import { z } from "zod";

export const schema = z.object({
  amount: z.string(),
  token: z.string().default("USDC"),
});

export async function POST(req: Request) {
  const body = await req.json();
  const { amount, token } = schema.parse(body);
  return Response.json({ ok: true, action: "unstake", amount, token });
}
\`\`\`

### Cron schedules (\`profile.schedule\`)

- GET-only tools require \`profile.schedule\` with a standard 5‚Äì6 field cron expression (e.g., \`0 12 * * *\` or \`0 0 ? * MON-FRI *\`).
- Build validates the cron shape and emits \`.well-known/opentool/cron.json\` capturing each scheduled tool (\`toolName\`, \`toolPath\`, \`scheduleExpression\`). Enabled defaults to \`false\` even if authors set it to \`true\` in code. Deployment targets can translate these cron strings to their provider format (e.g., EventBridge) downstream.

### Public tools: Add x402 payments (optional)

Protect your public tools with crypto payments using x402:

\`\`\`typescript
// tools/premium-report.ts
import { z } from "zod";
import { defineX402Payment } from "opentool/x402";

export const schema = z.object({
  symbol: z.string().describe("Crypto symbol (e.g., BTC)"),
});

export const payment = defineX402Payment({
  amount: "0.001",
  payTo: process.env.WALLET_ADDRESS!,
  currency: "USDC",
  network: "base-sepolia",
  message: "Premium analytics require payment",
});

export async function POST(request: Request) {
  const payload = await request.json();
  const { symbol } = schema.parse(payload);

  return Response.json({
    report: \`Premium analytics for \${symbol}\`,
  });
}
\`\`\`

Test the payment flow:

\`\`\`bash
# Start dev server
WALLET_ADDRESS=0x... npx opentool dev --input tools

# Test with the x402 client
PRIVATE_KEY=0x... bun examples/full-metadata/test-x402.ts
\`\`\`

Or test manually:

\`\`\`bash
# Get 402 response with payment requirements
curl -X POST http://localhost:7000/premium-report \\
  -H "content-type: application/json" \\
  -d '{"symbol":"BTC"}'

# Pay and retry with X-PAYMENT header (generated by x402 client)
curl -X POST http://localhost:7000/premium-report \\
  -H "content-type: application/json" \\
  -H "X-PAYMENT: \${X402_HEADER}" \\
  -d '{"symbol":"BTC"}'
\`\`\`

### MCP

By default, tools are HTTP-only. Want them accessible via MCP clients like Claude Desktop? Just add this to your tool file:

\`\`\`typescript
// tools/greet.ts
export const mcp = {
  enabled: true, // Now works with Claude Desktop, MCP Inspector, etc.
};
\`\`\`

Tools without this export stay HTTP-only, which is useful when you want selective access. Mix and match as needed.

### Testing with MCP Inspector

The \`examples/full-metadata\` project has an \`inspector.json\` config ready to go:

\`\`\`bash
cd examples/full-metadata
npx mcp-inspector --config inspector.json --server opentool-dev
\`\`\`

Copy \`.env.example\` to \`.env\` and add your credentials if you're using wallet/payment features. The inspector starts \`opentool dev\` automatically, so you only need one terminal. Only tools with \`mcp = { enabled: true }\` show up in the inspector - HTTP-only tools keep running on localhost.

### Quick x402 test with curl

1. Start the dev server against the example tools:

   \`\`\`bash
   npx opentool dev --input examples/full-metadata/tools
   \`\`\`

2. Trigger the paywall and inspect the returned payment requirements:

   \`\`\`bash
   curl -i \\
     -X POST http://localhost:7000/premium-report \\
     -H "content-type: application/json" \\
     -d '{"symbol":"BTC"}'
   \`\`\`

   The response includes a \`402 Payment Required\` status and JSON body with an \`x402.accepts[0]\` object describing the payment request.

3. Submit a follow-up request with an \`X-PAYMENT\` header produced by your x402 facilitator (for example, by using the Coinbase [x402](https://github.com/coinbase/x402) tooling or your own signing flow):

   \`\`\`bash
   curl -i \\
     -X POST http://localhost:7000/premium-report \\
     -H "content-type: application/json" \\
     -H "X-PAYMENT: \${X402_HEADER}" \\
     -d '{"symbol":"BTC"}'
   \`\`\`

   Replace \`\${X402_HEADER}\` with the base64-encoded payment payload returned by your facilitator‚Äôs \`/verify\` or \`/pay\` workflow. If the payment is valid the server responds with \`200 OK\`; otherwise it returns a new \`402\` with failure details.

### 5. Build for deployment

\`\`\`bash
# Build tools for Lambda deployment
npx opentool build
\`\`\`

### 6. Deploy to OpenPond

Create an account on [OpenPond](https://openpond.ai) and create a new project.

Add your project to the OpenPond project and connect it to your GitHub repository.

OpenPond will automatically detect the \`opentool\` dependency and deploy your tools to AWS Lambda.

## CLI Commands

### Build

Build your tools for deployment:

\`\`\`bash
npx opentool build [options]

Options:
  -i, --input <dir>      Input directory containing tools (default: "tools")
  -o, --output <dir>     Output directory for built tools (default: "dist")
  --name <name>          Server name (default: "opentool-server")
  --version <version>    Server version (default: "1.0.0")
\`\`\`

### Development Server

Start a local development server:

\`\`\`bash
npx opentool dev [options]

Options:
  -i, --input <dir>      Input directory containing tools (default: "tools")
  --watch                Watch for file changes (default: false)
\`\`\`

### Validate

Validate your tools:

\`\`\`bash
npx opentool validate [options]

Options:
  -i, --input <dir>      Input directory containing tools (default: "tools")
\`\`\`

### Generate Metadata

Generate \`metadata.json\` without building:

\`\`\`bash
npx opentool metadata [options]

Options:
  -i, --input <dir>      Input directory containing tools (default: "tools")
  -o, --output <file>    Output file path for metadata.json (default: "metadata.json")
  --name <name>          Server name (default: "opentool-server")
  --version <version>    Server version (default: "1.0.0")
\`\`\`

Generates the metadata file with tool schemas, payment configs, and discovery info. Useful for inspecting or sharing metadata without a full build.

## Tool Definition

Tools are just TypeScript files with a few exports:

\`\`\`typescript
import { z } from "zod";

// 1. Schema for input validation
export const schema = z.object({
  input: z.string().describe("Some input parameter"),
});

// 2. Metadata
export const metadata = {
  name: "my_tool",
  description: "What this tool does",
};

// 3. Optional: enable MCP mode
export const mcp = {
  enabled: true, // Makes it work with Claude Desktop, etc.
};

// 4. Handler (POST, GET, PUT, DELETE, etc.)
export async function POST(request: Request) {
  const payload = await request.json();
  const params = schema.parse(payload);

  // Your tool logic here
  return Response.json({
    result: "Tool response",
  });
}
\`\`\`

## Error Handling

Just return standard HTTP responses:

\`\`\`typescript
export async function POST(request: Request) {
  const payload = await request.json();
  const params = schema.parse(payload);

  if (someCondition) {
    return Response.json({ error: "Something went wrong" }, { status: 400 });
  }

  return Response.json({ result: "Success" });
}
\`\`\`

## Local Development

Run \`npx opentool dev\` to test your tools locally. It runs them via stdio (for MCP clients) or HTTP (for direct API calls). Good for:

- Testing tool logic
- Validating schemas
- Debugging before deployment

## Deployment

Push your repo to GitHub and connect it to [OpenPond](https://openpond.ai):

1. OpenPond detects the \`opentool\` dependency
2. Runs \`npx opentool build\`
3. Deploys to AWS Lambda with Function URLs
4. Done - your tools are live

## Examples

Check \`examples/full-metadata/\` for a complete example with payment and discovery features.

### Testing Examples Locally

\`\`\`bash
# Build and link the OpenTool package
npm run build
npm link

# Test the example
cd examples/full-metadata
npm link opentool
npm run build

# Check the output
cat dist/metadata.json

# Test the MCP server
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}' | node dist/mcp-server.js

# Or from repo root:
npm run examples:build      # Build example (CJS+ESM)
npm run examples:validate   # Validate metadata and tools
npm run examples:metadata   # Regenerate metadata.json
\`\`\`

## Metadata System

OpenTool has three levels of metadata config:

1. **Default** - pulls from your \`package.json\` automatically
2. **Project-level** - add a \`metadata.ts\` file for branding, payments, etc.
3. **Tool-level** - override metadata per tool

See [\`METADATA.md\`](./METADATA.md) for details on configuring metadata for on-chain registration and payments.

## What's Next

- Better watch mode that keeps metadata and tool artifacts synced during dev

## Contributing

Contributions welcome! See the [Contributing Guide](https://github.com/openpond/opentool/blob/master/CONTRIBUTING.md).

## License

MIT ¬© [OpenTool](https://opentool.dev)
`;

export const OPENTOOL_METADATA_GUIDE = `# OpenTool Metadata System

This guide explains how OpenTool's metadata system works, from simple automatic generation to full custom configuration for on-chain registration and payments.

## How It Works

OpenTool has a **three-tier metadata system** that gets progressively more sophisticated:

1. **üü¢ Automatic (Smart Defaults)** - Zero configuration required
2. **üî∏ Enhanced (metadata.ts)** - Custom configuration with smart fallbacks  
3. **üî¥ Full Control** - Complete tool-level overrides

The build process automatically generates a complete \`metadata.json\` file suitable for on-chain registration regardless of which tier you use.

## Tier 1: Smart Defaults (Zero Config)

For simple projects, OpenTool generates complete metadata automatically:

**What you provide:**
- \`package.json\` with basic fields
- Tool files in \`tools/\` directory

**What OpenTool generates automatically:**
\`\`\`json
{
  "metadataSpecVersion": "1.1.0",
  "name": "package-name",           // From package.json name
  "displayName": "Package Name",   // Formatted from name
  "version": "2.5.0",              // From package.json version (semantic string)
  "description": "...",            // From package.json description
  "author": "...",                 // From package.json author
  "repository": "...",             // From package.json repository
  "website": "...",                // From package.json homepage
  "category": "utility",           // Default fallback
  "termsOfService": "Please review terms before use.",
  "tools": [
    {
      "name": "filename",          // From .ts filename
      "description": "filename tool", // Auto-generated
      "inputSchema": { ... }       // From Zod schema
    }
  ]
}
\`\`\`

**Example project structure:**
\`\`\`
my-assistant/
‚îú‚îÄ‚îÄ package.json                 # Basic npm package info
‚îî‚îÄ‚îÄ tools/
    ‚îî‚îÄ‚îÄ greeting.ts              # Tool with schema and POST handler
\`\`\`

## Tier 2: Enhanced Metadata (metadata.ts)

Add a \`metadata.ts\` file to customize agent-wide settings while keeping smart defaults for missing fields:

\`\`\`typescript
export const metadata = {
  // Override smart defaults
  displayName: "My AI Assistant Pro",
  category: "productivity",
  
  // Add discovery fields  
  keywords: ["ai", "assistant", "productivity"],
  useCases: ["Customer support", "Content writing"],
  
  // Add payment configuration
  payment: {
    amountUSDC: 0.01,
    description: "Standard usage tier",
    x402: true,
    openpondDirect: true,
    acceptedMethods: ["USDC", "ETH"],
    chains: [8453] // Base
  },
  
  // Smart defaults still apply for: name, version, description, author, etc.
};
\`\`\`

The build process **merges** your metadata with smart defaults, so you only specify what you want to customize.

## Tier 3: Full Tool-Level Control

Individual tools can override agent defaults and add rich discovery metadata:

\`\`\`typescript
// tools/analyze.ts
import { z } from "zod";

export const schema = z.object({
  text: z.string().describe("Text to analyze")
});

export const metadata = {
  name: "text-analyzer",
  description: "Advanced text analysis with sentiment and keywords",
  
  // Override agent-level payment
  payment: {
    amountUSDC: 0.05,  // More expensive than agent default
    acceptETH: true,
    acceptSolana: true,
    acceptX402: true,
    chains: [8453]
  },
  
  // MCP annotations for behavior hints
  annotations: {
    readOnlyHint: true,     // Safe, only reads data
    idempotentHint: true,   // Same input = same output
  },
  
  // Rich discovery metadata
  discovery: {
    keywords: ["nlp", "sentiment", "analysis"],
    category: "ai-processing",
    examples: [
      {
        description: "Analyze customer feedback",
        input: { text: "This product is amazing!" },
        expectedOutput: "Sentiment: positive (0.9), Keywords: product, amazing"
      }
    ],
    performance: {
      estimatedDuration: 2000,
      isAsync: true
    },
    safety: {
      requiresConfirmation: false,
      isReversible: true,
      sideEffects: []
    }
  }
};

export async function POST(request: Request) {
  const payload = await request.json();
  const params = schema.parse(payload);

  // Implementation
  return Response.json({
    result: "Analysis complete",
  });
}
\`\`\`

## Build Process Flow

When you run \`opentool build\`, here's what happens:

1. **üìÇ Scan** \`tools/\` directory for \`.ts\`/\`.js\` files
2. **üîç Load** optional \`metadata.ts\` (or \`discovery.ts\` for backwards compatibility)
3. **üì¶ Read** \`package.json\` for fallback values
4. **üß† Generate** smart defaults from folder name if needed
5. **‚öôÔ∏è Compile** TypeScript tools to JavaScript
6. **üîó Merge** all metadata layers:
   - Tool metadata (highest priority)
   - Agent metadata from metadata.ts
   - Smart defaults from package.json
   - Built-in fallbacks (lowest priority)
7. **üìÑ Generate** complete \`metadata.json\`

## Metadata Hierarchy

The system uses this precedence order (highest to lowest):

\`\`\`
Tool-level metadata (in tool files)
     ‚Üì overrides
Agent-level metadata (metadata.ts) 
     ‚Üì overrides
Smart defaults (package.json + folder name)
     ‚Üì overrides
Built-in fallbacks (sensible defaults)
\`\`\`

## Payment Configuration

Payment settings work hierarchically:

\`\`\`typescript
// Agent-level default (metadata.ts)
export const metadata = {
  payment: {
    amountUSDC: 0.01,        // Default for all tools
    acceptETH: true,
    acceptSolana: true,
    acceptX402: true,
    chains: [8453]
  }
};

// Tool-level override (tools/premium.ts)
export const metadata = {
  payment: {
    amountUSDC: 0.10,        // Override: more expensive
    x402: true,
    openpondDirect: true,
    acceptedMethods: ["USDC"],
    chains: [8453]
  }
};
\`\`\`

**Payment Settings:**
- **acceptedMethods**: Currency codes accepted for settlement (e.g. \`USDC\`, \`ETH\`)
- **x402**: Enables HTTP 402 (paywall) flows
- **openpondDirect**: Enables direct settlement through OpenPond
- **chains**: Supported blockchain networks (accepts numbers like \`8453\` or strings like \`"base"\`)

## Blockchain Networks (Chains)

Specify which blockchain networks your agent/tools interact with using the \`chains\` field:

\`\`\`typescript
// Agent-level chains (metadata.ts)
export const metadata = {
  displayName: "Multi-Chain Trading Bot",

  // Chains accepts numbers (EVM chain IDs) or strings (chain names)
  chains: [
    1,                  // Ethereum mainnet (EVM chain ID)
    8453,               // Base (EVM chain ID)
    "base-sepolia",     // Base testnet (Alchemy naming)
    "solana",           // Solana (chain name)
    "hyperliquid"       // Hyperliquid (chain name)
  ]
};

// Tool-level override (tools/ethereum-swap.ts)
export const metadata = {
  name: "ethereum-swap",
  chains: [1, "ethereum"]  // Only Ethereum for this tool
};
\`\`\`

**Chain Format:**
- **Numbers**: EVM chain IDs (e.g., \`1\`=Ethereum, \`8453\`=Base, \`42161\`=Arbitrum)
- **Strings**: Chain names following Alchemy naming conventions (e.g., \`"base-sepolia"\`, \`"solana"\`, \`"hyperliquid"\`)

**Common Chain IDs:**
- Ethereum: \`1\`
- Base: \`8453\`
- Arbitrum: \`42161\`
- Polygon: \`137\`
- Optimism: \`10\`

**Hierarchy:**
- Tools inherit agent-level chains by default
- Tool-level chains override agent chains for that specific tool
- Used for discovery, filtering, and showing network-specific UI

## Generated Metadata JSON

The final \`metadata.json\` combines all metadata into a standardized format:

\`\`\`json
{
  "metadataSpecVersion": "1.1.0",
  "name": "my-assistant",
  "displayName": "My AI Assistant Pro",
  "version": "2.5.0",
  "description": "A helpful AI assistant for productivity tasks",
  "author": "Jane Developer",
  "repository": "https://github.com/jane/my-ai-assistant",
  "website": "https://my-ai-assistant.com",
  "category": "productivity",
  "termsOfService": "Please review terms before use.",
  "chains": [8453, "base-sepolia"],

  "tools": [
    {
      "name": "text-analyzer",
      "description": "Advanced text analysis with sentiment and keywords",
      "inputSchema": { /* JSON Schema from Zod */ },
      "payment": { /* Tool-specific payment config */ },
      "annotations": { /* MCP behavior hints */ },
      "discovery": { /* SEO and discovery metadata */ },
      "chains": [8453, "base-sepolia"]
    }
  ],

  "payment": { /* Agent-level payment defaults */ },
  "discovery": { /* Agent-level discovery metadata */ }
}
\`\`\`

## Best Practices

### üü¢ Start Simple
Begin with just \`package.json\` and tool files. OpenTool handles the rest automatically.

### üî∏ Add Metadata When Needed
Create \`metadata.ts\` only when you need:
- Custom branding (displayName, category)
- Payment configuration
- Discovery/SEO optimization

### üî¥ Tool-Level Overrides Sparingly
Use tool-level metadata for:
- Different pricing tiers
- Tool-specific behavior hints
- Rich examples and documentation

### üí∞ Pricing Guidelines
- **Free/Demo**: \`amountUSDC: 0\`
- **Simple Operations**: \`0.001 - 0.01 USDC\`
- **Complex Processing**: \`0.01 - 0.1 USDC\`  
- **Premium Features**: \`0.1+ USDC\`

### üîí Safety Annotations
Always set accurate MCP annotations:
- \`readOnlyHint: true\` for data-reading tools
- \`destructiveHint: true\` for irreversible operations
- \`idempotentHint: true\` if same input always gives same result

## On-Chain Registration

The generated \`metadata.json\` enables decentralized discovery:

1. **Deploy** your agent to AWS Lambda or supported platform
2. **Register** on-chain through the wallet UI
3. **Discover** agents are indexed by category, keywords, and capabilities
4. **Payments** are automatically processed through configured methods

## Example Projects

See \`examples/full-metadata\` for a full configuration that demonstrates agent metadata, tool-level overrides, and the dual-module build outputs.
`;

export const OPENTOOL_EXAMPLES: Record<string, string> = {
  "hello.ts": `import { z } from "zod";
import { hello } from "../utils";

hello();
export const schema = z.object({
  name: z.string().describe("Name of the person to greet"),
});

export const metadata = {
  name: "hello",
  description: "Simple greeting tool for testing",
  annotations: {
    readOnlyHint: true,
    idempotentHint: true,
  },
};

export async function POST(request: Request) {
  const payload = await request.json();
  const { name } = schema.parse(payload);

  return Response.json({
    message: \`Hello, \${name}!\`,
    timestamp: new Date().toISOString(),
  });
}
`,
  "premium-report.ts": `import { defineX402Payment } from "opentool/x402";
import { z } from "zod";

export const schema = z.object({
  symbol: z
    .string()
    .min(1)
    .default("BTC")
    .describe("Ticker symbol to generate a premium market summary for"),
});

export const payment = defineX402Payment({
  amount: "0.001",
  currency: "USDC",
  payTo: process.env.WALLET_ADDRESS!,
  message: "Premium analytics require payment before access.",
  resource: "https://localhost:7000/premium-report",
  network: "base-sepolia",
  assetAddress: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  scheme: "exact",
  facilitator: "http://localhost:8080",
});

export const mcp = { enabled: true };

export async function POST(request: Request) {
  const payload = await request.json();
  const { symbol } = schema.parse(payload);
  return new Response(
    JSON.stringify({
      report: "Hello World",
    }),
    {
      status: 200,
    }
  );
}
`,
  "mcp-ping.ts": `import { z } from "zod";

export const schema = z.object({
  message: z.string().default("ping").describe("Optional message to echo back"),
});

export const metadata = {
  name: "mcp_ping",
  description: "Simple tool to verify MCP + HTTP dual-mode behaviour",
};

export const mcp = { enabled: true };

export async function POST(request: Request) {
  let json: unknown;
  try {
    json = await request.json();
  } catch {
    json = {};
  }

  const { message } = schema.parse(json ?? {});

  return Response.json({
    message,
    transport: request.headers.get("x-opentool-invocation") ?? "http",
    timestamp: new Date().toISOString(),
  });
}
`,
  "ai-research.ts": `import { flattenMessageContent, generateText } from "opentool/ai";
import { z } from "zod";

const aiConfig = {
  baseUrl: process.env.OPENPOND_GATEWAY_URL,
  apiKey: process.env.OPENPOND_API_KEY,
};

export const schema = z.object({
  query: z
    .string()
    .min(5)
    .describe("Research question or topic to investigate"),
  maxResults: z
    .number()
    .int()
    .min(1)
    .max(10)
    .default(5)
    .describe("Maximum number of web results to inspect"),
  model: z
    .string()
    .optional()
    .describe(
      "Override default model for research (provider/model format or short name)"
    ),
});

export const metadata = {
  name: "ai_research",
  description:
    "Investigate a topic using the gateway websearch tool and return sourced findings",
  annotations: {
    readOnlyHint: true,
    idempotentHint: false,
  },
  discovery: {
    keywords: ["research", "websearch", "exa", "analysis", "ai", "report"],
    category: "ai_assistant",
    useCases: [
      "Collect recent news with citations",
      "Summarize documentation updates",
      "Scan market insights",
      "Compile security advisories",
    ],
    examples: [
      {
        description: "Summarize the latest MCP protocol releases",
        input: {
          query: "Recent Model Context Protocol updates",
          maxResults: 3,
        },
        expectedOutput:
          "Short narrative with bullet citations pointing to authoritative sources.",
      },
      {
        description: "Investigate a new AI model",
        input: {
          query: "OpenAI gpt-5-mini capabilities",
          maxResults: 4,
          model: "claude-4-sonnet-20250514",
        },
        expectedOutput:
          "Structured analysis referencing each source and highlighting strengths/risks.",
      },
    ],
    relatedTools: ["ai_summarize", "trend_monitor", "intel_digest"],
  },
};

export async function POST(request: Request) {
  const payload = schema.parse(await request.json());

  const response = await generateText(
    {
      messages: [
        {
          role: "system" as const,
          content:
            "You are an investigative assistant. Use the websearch tool when the user asks for current information.",
        },
        {
          role: "user" as const,
          content: [
            {
              type: "text" as const,
              text: \`Research request: \${payload.query}\\nReturn findings with inline citations and a final verdict line.\`,
            },
          ],
        },
      ],
      model: payload.model,

      toolExecution: {
        enableTools: true,
        webSearch: {
          limit: payload.maxResults,
        },
      },
      toolChoice: "auto",
    },
    aiConfig
  );

  const analysis = flattenMessageContent(response.message.content);

  return Response.json({
    analysis,
    model: response.model,
    finishReason: response.finishReason,
    usage: response.usage,
  });
}
`,
  "calculate.ts": `import { z } from "zod";

export const schema = z.object({
  operation: z
    .enum(["add", "subtract", "multiply", "divide"])
    .describe("Mathematical operation to perform"),
  a: z.number().describe("First number"),
  b: z.number().describe("Second number"),
});

export const metadata = {
  name: "calculate",
  description: "Perform basic mathematical operations on two numbers",
  annotations: {
    readOnlyHint: true,
    idempotentHint: true,
  },
  payment: {
    amountUSDC: 0.001,
    description: "Basic mathematical operations",
    x402: true,
    plain402: true,
    acceptedMethods: ["x402", "402"],
    acceptedCurrencies: ["USDC"],
    chains: [8453],
    facilitator: "opentool",
  },
  discovery: {
    keywords: ["math", "calculation", "arithmetic", "numbers", "compute"],
    category: "mathematics",
    useCases: [
      "Basic calculator functionality in applications",
      "Financial calculations and cost computations",
      "Mathematical operations in data processing",
      "Educational tools for learning arithmetic",
    ],
    examples: [
      {
        description: "Simple addition",
        input: { operation: "add", a: 5, b: 3 },
        expectedOutput: "5 add 3 = 8",
      },
      {
        description: "Division with decimal result",
        input: { operation: "divide", a: 10, b: 3 },
        expectedOutput: "10 divide 3 = 3.3333333333333335",
      },
    ],
    relatedTools: ["advanced_math", "statistical_analysis"],
    performance: {
      estimatedDuration: 10,
      isAsync: false,
    },
    cost: {
      complexity: "low",
      resourceUsage: {
        cpu: "low",
        memory: "low",
        network: "low",
      },
    },
    safety: {
      requiresConfirmation: false,
      isReversible: true,
      sideEffects: [],
      validationErrors: ["Division by zero"],
    },
  },
};

export async function POST(request: Request) {
  const payload = await request.json();
  const { operation, a, b } = schema.parse(payload);

  let result: number;

  switch (operation) {
    case "add":
      result = a + b;
      break;
    case "subtract":
      result = a - b;
      break;
    case "multiply":
      result = a * b;
      break;
    case "divide":
      if (b === 0) {
        return Response.json(
          { error: "Cannot divide by zero" },
          { status: 400 }
        );
      }
      result = a / b;
      break;
    default:
      return Response.json({ error: "Invalid operation" }, { status: 400 });
  }

  return Response.json({
    result: \`\${a} \${operation} \${b} = \${result}\`,
    computation: { operation, a, b, result },
  });
}
`,
  "aave-unstake.ts": `// POST-only one-off unstake tool using OpenTool wallet + Aave V3 Pool
import { wallet } from "opentool/wallet";
import { parseUnits } from "viem";
import { z } from "zod";

const AAVE_POOL_ABI = [
  {
    type: "function",
    name: "withdraw",
    stateMutability: "nonpayable",
    inputs: [
      { name: "asset", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "to", type: "address" },
    ],
    outputs: [{ name: "", type: "uint256" }],
  },
];

export const schema = z.object({
  amount: z.string(),
  token: z.string().default("USDC"),
});

export async function POST(req: Request) {
  const body = await req.json();
  const { amount, token } = schema.parse(body);

  const ctx = await wallet({
    chain: "base-sepolia",
    apiKey: process.env.ALCHEMY_API_KEY,
    rpcUrl: process.env.RPC_URL,
    turnkey: {
      organizationId: process.env.TURNKEY_SUBORG_ID!,
      apiPublicKey: process.env.TURNKEY_API_PUBLIC_KEY!,
      apiPrivateKey: process.env.TURNKEY_API_PRIVATE_KEY!,
      signWith: process.env.TURNKEY_WALLET_ADDRESS!,
      apiBaseUrl: process.env.TURNKEY_API_BASE_URL,
    },
  });

  const AAVE_POOL = "0x6Ae43d3271ff6888e7Fc43Fd7321a503ff738951" as \`0x\${string}\`; // Base Sepolia Pool
  const TOKEN_ADDRESS = "0xba50cd2a20f6da35d788639e581bca8d0b5d4d5f" as \`0x\${string}\`; // Base Sepolia USDC
  const amountUnits = parseUnits(amount, 6);

  // Withdraw from Aave Pool
  const withdrawHash = await ctx.walletClient.writeContract({
    address: AAVE_POOL,
    abi: AAVE_POOL_ABI as any,
    functionName: "withdraw",
    args: [TOKEN_ADDRESS, amountUnits, ctx.address],
    account: ctx.account,
  });

  // No content response (intentionally empty)
  return new Response(null, { status: 204 });
}
`,
  "ai-summarize.ts": `import { flattenMessageContent, generateText } from "opentool/ai";
import { z } from "zod";

const aiConfig = {
  baseUrl: process.env.OPENPOND_GATEWAY_URL,
  apiKey: process.env.OPENPOND_API_KEY,
};

export const schema = z.object({
  topic: z.string().min(3).describe("Subject to summarize"),
  focus: z
    .string()
    .optional()
    .describe("Key angle or audience focus for the summary"),
  tone: z
    .enum(["neutral", "enthusiastic", "technical", "casual"])
    .default("neutral")
    .describe("Desired tone of the summary"),
  maxTokens: z
    .number()
    .int()
    .min(200)
    .max(1200)
    .default(400)
    .describe("Token limit for the generated summary"),
  model: z
    .string()
    .optional()
    .describe("Override default model (e.g., 'claude-4-sonnet-20250514')"),
});

export const metadata = {
  name: "ai_summarize",
  description:
    "Generate concise summaries tailored to different tones and audiences",
  annotations: {
    readOnlyHint: true,
    idempotentHint: false,
  },
  discovery: {
    keywords: [
      "summary",
      "writing",
      "gpt",
      "content",
      "documentation",
      "analysis",
    ],
    category: "ai_generation",
    useCases: [
      "Produce release note drafts",
      "Summarize product feedback",
      "Generate onboarding copy",
      "Create meeting recaps",
    ],
    examples: [
      {
        description: "Summarize a new feature announcement",
        input: {
          topic: "OpenTool AI package release",
          focus: "Benefits for external tool builders",
          tone: "enthusiastic",
        },
        expectedOutput:
          "A short paragraph highlighting what the AI package enables and why it matters.",
      },
      {
        description: "Create a technical briefing",
        input: {
          topic: "Server-sent events in the OpenPond gateway",
          tone: "technical",
          maxTokens: 600,
        },
        expectedOutput:
          "Detailed explanation that references stream mechanics and abort behavior.",
      },
    ],
    relatedTools: ["ai_brainstorm", "doc_generator", "release_notes"],
  },
};

export async function POST(request: Request) {
  const payload = schema.parse(await request.json());

  const response = await generateText(
    {
      messages: [
        {
          role: "system",
          content:
            "You are a helpful technical writer. Summaries should be factual, concise, and respect the requested tone.",
        },
        {
          role: "user",
          content: [
            \`Topic: \${payload.topic}\`,
            \`Tone: \${payload.tone}\`,
            payload.focus ? \`Focus: \${payload.focus}\` : undefined,
            "Output: A coherent paragraph plus 3 bullet takeaways.",
          ]
            .filter(Boolean)
            .join("\\n"),
        },
      ],
      model: payload.model,
    },
    aiConfig
  );

  const summary = flattenMessageContent(response.message.content);

  return Response.json({
    summary,
    model: response.model,
    finishReason: response.finishReason,
    usage: response.usage,
  });
}
`,
  "ai-streaming-outline.ts": `import { streamText } from "opentool/ai";
import { z } from "zod";

const aiConfig = {
  baseUrl: process.env.OPENPOND_GATEWAY_URL,
  apiKey: process.env.OPENPOND_API_KEY,
};

export const schema = z.object({
  topic: z.string().min(3).describe("Subject to outline"),
  bulletCount: z
    .number()
    .int()
    .min(3)
    .max(12)
    .default(6)
    .describe("How many bullet points to include"),
  includeSummary: z
    .boolean()
    .default(true)
    .describe("Whether to append a short summary after the bullet list"),
});

export const metadata = {
  name: "ai_streaming_outline",
  description:
    "Demonstrate streaming outline generation with incremental deltas",
  annotations: {
    readOnlyHint: true,
    idempotentHint: false,
  },
  discovery: {
    keywords: ["streaming", "outline", "ai", "demo"],
    category: "ai_generation",
    useCases: [
      "Live-generate outlines for docs",
      "Demonstrate streaming handler usage",
      "Prototype interactive drafting workflows",
    ],
    examples: [
      {
        description: "Create a product launch outline",
        input: {
          topic: "OpenTool AI package launch",
          bulletCount: 5,
          includeSummary: true,
        },
        expectedOutput:
          "Outline text streamed in chunks, with a concluding summary paragraph.",
      },
    ],
    relatedTools: ["ai_summarize", "ai_code_suggestion", "ai_research"],
  },
};

export async function POST(request: Request) {
  const payload = schema.parse(await request.json());

  const textChunks: string[] = [];
  const reasoningChunks: string[] = [];
  const toolSignals: unknown[] = [];
  let usage: Record<string, unknown> | undefined;

  try {
    const { finished } = await streamText(
      {
        messages: [
          {
            role: "system",
            content:
              "You produce well-structured outlines. Stream bullet items as they are ready, then append an optional summary.",
          },
          {
            role: "user",
            content: [
              \`Topic: \${payload.topic}\`,
              \`Bullets: \${payload.bulletCount}\`,
              payload.includeSummary
                ? "Include a short summary paragraph."
                : undefined,
            ]
              .filter(Boolean)
              .join("\\n"),
          },
        ],
        generation: {
          temperature: 0.6,
          maxTokens: 600,
          responseFormat: "text",
        },
        includeUsage: true,
        sendReasoning: true,
        handlers: {
          onTextDelta: (delta) => {
            textChunks.push(delta);
          },
          onReasoningDelta: (delta) => {
            reasoningChunks.push(delta);
          },
          onToolCallDelta: (call) => {
            toolSignals.push(call);
          },
          onUsage: (stats) => {
            usage = stats;
          },
        },
      },
      aiConfig
    );

    await finished;
  } catch (error) {
    return Response.json(
      {
        error: "Streaming generation failed",
        message: error instanceof Error ? error.message : String(error),
      },
      { status: 502 }
    );
  }

  return Response.json({
    outline: textChunks.join(""),
    reasoning:
      reasoningChunks.length > 0 ? reasoningChunks.join("") : undefined,
    toolSignals: toolSignals.length > 0 ? toolSignals : undefined,
    usage,
  });
}
`,
  "aave-stake-simple.ts": `import { z } from "zod";
import { wallet } from "opentool/wallet";
import { parseUnits } from "viem";

// POST-only one-off staking tool mirroring aave-stake.ts behavior
export const profile = {
  description: "Stake a user-specified USDC amount to Aave (Base Sepolia)",
};

export const schema = z.object({
  amount: z
    .string()
    .min(1, "amount is required")
    .refine(
      (v) => /^\\d+(?:\\.\\d+)?$/.test(v),
      "amount must be a decimal string"
    ),
});

const ERC20_ABI = [
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" },
    ],
    outputs: [{ name: "", type: "bool" }],
  },
];

const AAVE_POOL_ABI = [
  {
    type: "function",
    name: "supply",
    stateMutability: "nonpayable",
    inputs: [
      { name: "asset", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "onBehalfOf", type: "address" },
      { name: "referralCode", type: "uint16" },
    ],
    outputs: [],
  },
];

export async function POST(req: Request) {
  const body = await req.json().catch(() => ({}));
  const { amount } = schema.parse(body);

  // Establish wallet context (same network and envs as aave-stake.ts)
  const ctx = await wallet({
    chain: "base-sepolia",
    apiKey: process.env.ALCHEMY_API_KEY,
    rpcUrl: process.env.RPC_URL,
    turnkey: {
      organizationId: process.env.TURNKEY_SUBORG_ID!,
      apiPublicKey: process.env.TURNKEY_API_PUBLIC_KEY!,
      apiPrivateKey: process.env.TURNKEY_API_PRIVATE_KEY!,
      signWith: process.env.TURNKEY_WALLET_ADDRESS!,
      apiBaseUrl: process.env.TURNKEY_API_BASE_URL,
    },
  });

  // Constants (Base Sepolia values from aave-stake.ts)
  const AAVE_POOL =
    "0x8bab6d1b75f19e9ed9fce8b9bd338844ff79ae27" as \`0x\${string}\`; // Base Sepolia Pool
  const TOKEN_ADDRESS =
    "0xba50cd2a20f6da35d788639e581bca8d0b5d4d5f" as \`0x\${string}\`; // Base Sepolia USDC
  const amountUnits = parseUnits(amount, 6);

  // 1) Approve pool to spend USDC
  const approveHash = await ctx.walletClient.writeContract({
    address: TOKEN_ADDRESS,
    abi: ERC20_ABI as any,
    functionName: "approve",
    args: [AAVE_POOL, amountUnits],
    account: ctx.account,
  });

  // Wait for approve to be mined to avoid replacement/nonce conflicts
  await ctx.publicClient.waitForTransactionReceipt({ hash: approveHash });

  // Slightly bump fees to avoid "replacement underpriced" on congested testnets
  let feeOverrides: { maxFeePerGas?: bigint; maxPriorityFeePerGas?: bigint } =
    {};
  try {
    const fee = await ctx.publicClient.estimateFeesPerGas();
    if (fee.maxFeePerGas && fee.maxPriorityFeePerGas) {
      // +20% bump over suggestion
      feeOverrides = {
        maxFeePerGas: (fee.maxFeePerGas * 12n) / 10n,
        maxPriorityFeePerGas: (fee.maxPriorityFeePerGas * 12n) / 10n,
      };
    }
  } catch {}

  // 2) Supply to Aave Pool with fee bump
  const supplyHash = await ctx.walletClient.writeContract({
    address: AAVE_POOL,
    abi: AAVE_POOL_ABI as any,
    functionName: "supply",
    args: [TOKEN_ADDRESS, amountUnits, ctx.address, 0],
    account: ctx.account,
    ...feeOverrides,
  });

  return Response.json({
    ok: true,
    action: "stake",
    amount,
    approveHash,
    supplyHash,
  });
}
`,
  "aave-stake.ts": `// GET-only scheduled staking tool using OpenTool wallet + Aave V3 Pool
import { wallet } from "opentool/wallet";
import { store } from "opentool/store";
import { parseUnits } from "viem";

const ERC20_ABI = [
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" },
    ],
    outputs: [{ name: "", type: "bool" }],
  },
];

const AAVE_POOL_ABI = [
  {
    type: "function",
    name: "supply",
    stateMutability: "nonpayable",
    inputs: [
      { name: "asset", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "onBehalfOf", type: "address" },
      { name: "referralCode", type: "uint16" },
    ],
    outputs: [],
  },
];
export const profile = {
  description: "Stake 1 USDC every 2 minutes",
  fixedAmount: "1",
  tokenSymbol: "USDC",
  schedule: { cron: "*/2 * * * *", enabled: true },
  limits: { concurrency: 1, dailyCap: 1 },
};

export async function GET(_req: Request) {
  const amount = profile.fixedAmount || "1";

  const ctx = await wallet({
    chain: "base-sepolia",
    apiKey: process.env.ALCHEMY_API_KEY,
    rpcUrl: process.env.RPC_URL,
    turnkey: {
      organizationId: process.env.TURNKEY_SUBORG_ID!,
      apiPublicKey: process.env.TURNKEY_API_PUBLIC_KEY!,
      apiPrivateKey: process.env.TURNKEY_API_PRIVATE_KEY!,
      signWith: process.env.TURNKEY_WALLET_ADDRESS!,
      apiBaseUrl: process.env.TURNKEY_API_BASE_URL,
    },
  });

  // Constants (Base Sepolia values from aave-stake.ts)
  const AAVE_POOL =
    "0x8bab6d1b75f19e9ed9fce8b9bd338844ff79ae27" as \`0x\${string}\`; // Base Sepolia Pool
  const TOKEN_ADDRESS =
    "0xba50cd2a20f6da35d788639e581bca8d0b5d4d5f" as \`0x\${string}\`; // Base Sepolia USDC
  const amountUnits = parseUnits(amount, 6);

  // 1) Approve pool to spend USDC
  const approveHash = await ctx.walletClient.writeContract({
    address: TOKEN_ADDRESS,
    abi: ERC20_ABI as any,
    functionName: "approve",
    args: [AAVE_POOL, amountUnits],
    account: ctx.account,
  });

  // Wait for approve to be mined to avoid replacement/nonce conflicts
  await ctx.publicClient.waitForTransactionReceipt({ hash: approveHash });

  // Slightly bump fees to avoid "replacement underpriced" on congested testnets
  let feeOverrides: { maxFeePerGas?: bigint; maxPriorityFeePerGas?: bigint } =
    {};
  try {
    const fee = await ctx.publicClient.estimateFeesPerGas();
    if (fee.maxFeePerGas && fee.maxPriorityFeePerGas) {
      // +20% bump over suggestion
      feeOverrides = {
        maxFeePerGas: (fee.maxFeePerGas * 12n) / 10n,
        maxPriorityFeePerGas: (fee.maxPriorityFeePerGas * 12n) / 10n,
      };
    }
  } catch {}

  // 2) Supply to Aave Pool with fee bump
  const supplyHash = await ctx.walletClient.writeContract({
    address: AAVE_POOL,
    abi: AAVE_POOL_ABI as any,
    functionName: "supply",
    args: [TOKEN_ADDRESS, amountUnits, ctx.address, 0],
    account: ctx.account,
    ...feeOverrides,
  });

  // Record the supply tx in the OpenPond activity store
  await store({
    source: "aave-v3", // protocol identifier doubles as source
    ref: supplyHash,
    status: "submitted",
    chainId: ctx.chain.id,
    walletAddress: ctx.address,
    action: "stake",
    notional: amount,
    metadata: {
      tool: "aave-stake",
      approveHash,
    },
  });

  // No content response (intentionally empty)
  return new Response(null, { status: 204 });
}
`,
  "ai-code-suggestion.ts": `import { flattenMessageContent, generateText } from "opentool/ai";
import { z } from "zod";

const aiConfig = {
  baseUrl: process.env.OPENPOND_GATEWAY_URL,
  apiKey: process.env.OPENPOND_API_KEY,
};

export const schema = z.object({
  language: z
    .enum(["typescript", "python", "rust", "go", "bash"])
    .describe("Target programming language"),
  task: z.string().min(5).describe("What the code snippet should accomplish"),
  constraints: z
    .array(z.string().min(1))
    .default([])
    .describe("Additional requirements, such as libraries or style"),
  tests: z
    .boolean()
    .default(true)
    .describe("Whether to include a lightweight test or usage example"),
});

export const metadata = {
  name: "ai_code_suggestion",
  description:
    "Draft language-specific code snippets with optional usage examples",
  annotations: {
    readOnlyHint: true,
    idempotentHint: false,
  },
  discovery: {
    keywords: [
      "code generation",
      "ai",
      "developer",
      "snippet",
      "typescript",
      "python",
    ],
    category: "developer_tools",
    useCases: [
      "Produce quick reference snippets",
      "Draft helper utilities",
      "Prototype CLI commands",
      "Bootstrap integration tests",
    ],
    examples: [
      {
        description: "Generate a TypeScript utility",
        input: {
          language: "typescript",
          task: "Convert snake_case keys to camelCase",
          constraints: ["avoid lodash", "include JSDoc"],
        },
        expectedOutput:
          "Complete function with inline documentation and optional usage block.",
      },
      {
        description: "Draft a Python CLI snippet",
        input: {
          language: "python",
          task: "List files in a directory with size metadata",
          tests: false,
        },
        expectedOutput:
          "Self-contained CLI using argparse with error handling.",
      },
    ],
    relatedTools: ["ai_research", "ai_summarize", "code_review"],
    performance: {
      estimatedDuration: 15,
      isAsync: false,
    },
  },
};

export async function POST(request: Request) {
  const payload = schema.parse(await request.json());

  const response = await generateText(
    {
      messages: [
        {
          role: "system",
          content:
            "You are an expert software engineer. Provide well-commented code that follows modern best practices.",
        },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: \`Language: \${payload.language} Task: \${payload.task}\`,
            },
          ],
        },
      ],
    },
    aiConfig
  );

  const code = flattenMessageContent(response.message.content);
  return Response.json({
    code: code?.trim() ?? "",
    model: response.model,
    finishReason: response.finishReason,
    usage: response.usage,
  });
}
`,
  "wallet-inspector.ts": `import { wallet } from "opentool/wallet";

export async function POST(): Promise<Response> {
  const context = await wallet({
    chain: "base-sepolia",
    apiKey: process.env.ALCHEMY_API_KEY,
    turnkey: {
      organizationId: process.env.TURNKEY_ORGANIZATION_ID!,
      apiPublicKey: process.env.TURNKEY_API_PUBLIC_KEY!,
      apiPrivateKey: process.env.TURNKEY_API_PRIVATE_KEY!,
      signWith: process.env.TURNKEY_SIGN_WITH as \`0x\${string}\`,
    },
  });

  const balance = await context.getNativeBalance();
  const transferAmount = balance / 2n;
  const recipient = "0x0000000000000000000000000000000000000000";

  console.log(balance.toString());

  let txHash: string | null = null;

  if (transferAmount > 0n) {
    txHash = await context.transfer({
      to: recipient,
      amount: transferAmount,
    });
  }

  /*  const sdk = createClientV2({
    apiKey: zeroXApiKey,
  });

  const quote = await sdk.swap.allowanceHolder.getQuote.query({
    sellToken: "USDC",
    buyToken: "WETH",
    sellAmount: "1000000",
    taker: context.address,
    chainId: 8453,
  });

  if (!quote.liquidityAvailable) {
    throw new Error("0x quote did not return a transaction");
  }

  const { transaction } = quote;

  const txHash = await context.transfer({
    to: transaction.to as \`0x\${string}\`,
    amount: BigInt(transaction.value ?? "0"),
    ...(transaction.data ? { data: transaction.data as \`0x\${string}\` } : {}),
  }); */

  return new Response(
    JSON.stringify(
      {
        balance: balance.toString(),
        transfer:
          transferAmount > 0n
            ? {
                to: recipient,
                amount: transferAmount.toString(),
                txHash,
              }
            : {
                to: recipient,
                amount: transferAmount.toString(),
                message: "Insufficient balance to transfer",
              },
      },
      null,
      2
    ),
    {
      status: 200,
      headers: { "content-type": "application/json; charset=utf-8" },
    }
  );
}
`,
};

export const OPENTOOL_WALLET_SOURCE: Record<string, string> = {
  "src/wallets/constants.ts": `import { zeroAddress } from "viem";
import { base, baseSepolia, mainnet } from "viem/chains";

import type {
  ChainMetadata,
  ChainTokenMap,
  HexAddress,
  RpcUrlResolver,
  WalletRegistry,
} from "./types";

const BASE_ALCHEMY_HOST = "https://base-mainnet.g.alchemy.com/v2/";
const ETHEREUM_ALCHEMY_HOST = "https://eth-mainnet.g.alchemy.com/v2/";
const BASE_SEPOLIA_ALCHEMY_HOST = "https://base-sepolia.g.alchemy.com/v2/";

function buildRpcResolver(
  host: string,
  fallbackUrls: readonly string[]
): RpcUrlResolver {
  return (options) => {
    if (options?.url) {
      return options.url;
    }

    if (options?.apiKey) {
      return \`\${host}\${options.apiKey}\`;
    }

    if (fallbackUrls.length > 0) {
      return fallbackUrls[0];
    }

    throw new Error(
      "No RPC URL available: supply a full url via options or an apiKey for the default host"
    );
  };
}

const chains: Record<string, ChainMetadata> = {
  base: {
    id: base.id,
    slug: "base",
    name: "Base",
    chain: base,
    rpcUrl: buildRpcResolver(BASE_ALCHEMY_HOST, base.rpcUrls.default.http),
    publicRpcUrls: base.rpcUrls.default.http,
  },
  ethereum: {
    id: mainnet.id,
    slug: "ethereum",
    name: "Ethereum",
    chain: mainnet,
    rpcUrl: buildRpcResolver(
      ETHEREUM_ALCHEMY_HOST,
      mainnet.rpcUrls.default.http
    ),
    publicRpcUrls: mainnet.rpcUrls.default.http,
  },
  baseSepolia: {
    id: baseSepolia.id,
    slug: "base-sepolia",
    name: "Base Sepolia",
    chain: baseSepolia,
    rpcUrl: buildRpcResolver(
      BASE_SEPOLIA_ALCHEMY_HOST,
      baseSepolia.rpcUrls.default.http
    ),
  },
};

function createNativeToken(
  chainId: number,
  symbol: string,
  name: string
): ChainTokenMap {
  return {
    [symbol]: {
      symbol,
      name,
      decimals: 18,
      address: zeroAddress,
      chainId,
      isNative: true,
    },
  };
}

function token(
  chainId: number,
  symbol: string,
  name: string,
  address: HexAddress,
  decimals: number
) {
  return {
    symbol,
    name,
    decimals,
    address,
    chainId,
  };
}

const tokens: Record<string, ChainTokenMap> = {
  base: {
    ...createNativeToken(base.id, "ETH", "Ether"),
    USDC: token(
      base.id,
      "USDC",
      "USD Coin",
      "0x833589fCD6eDb6E08f4c7C31c9A8Ba32D74b86B2",
      6
    ),
  },
  ethereum: {
    ...createNativeToken(mainnet.id, "ETH", "Ether"),
    USDC: token(
      mainnet.id,
      "USDC",
      "USD Coin",
      "0xA0b86991c6218b36c1d19d4a2e9Eb0cE3606eB48",
      6
    ),
  },
};

export const DEFAULT_CHAIN = chains.base;
export const DEFAULT_TOKENS = tokens.base;

export const registry: WalletRegistry = {
  chains,
  tokens,
};

export { chains, tokens };
`,
  "src/wallets/index.ts": `export * from "./types";
export { chains, tokens, registry, DEFAULT_CHAIN, DEFAULT_TOKENS } from "./constants";

import { createPublicClient, http } from "viem";

import type {
  RpcProviderOptions,
  WalletContext,
  WalletFullContext,
  WalletReadonlyContext,
  WalletOptions,
  WalletProviderType,
  WalletPrivateKeyOptions,
  WalletTurnkeyOptions,
  WalletReadonlyOptions,
} from "./types";
import {
  chains as chainRegistry,
  tokens as tokenRegistry,
  registry as walletRegistry,
  DEFAULT_CHAIN,
  DEFAULT_TOKENS,
} from "./constants";
import { createPrivateKeyProvider } from "./providers/private-key";
import { createTurnkeyProvider } from "./providers/turnkey";

type ChainSlug = keyof typeof chainRegistry;

function resolveChainSlug(reference?: string | number): ChainSlug {
  if (reference === undefined) {
    return (Object.entries(chainRegistry).find(([, meta]) => meta.id === DEFAULT_CHAIN.id)?.[0] ||
      DEFAULT_CHAIN.slug) as ChainSlug;
  }

  if (typeof reference === "number") {
    const match = Object.entries(chainRegistry).find(([, meta]) => meta.id === reference);
    if (match) {
      return match[0] as ChainSlug;
    }
  } else if (typeof reference === "string") {
    const sanitize = (value: string) => value.toLowerCase().replace(/[^a-z0-9]/g, "");

    if (reference in chainRegistry) {
      return reference as ChainSlug;
    }

    const normalized = sanitize(reference);

    const keyMatch = Object.entries(chainRegistry).find(([key]) => sanitize(key) === normalized);
    if (keyMatch) {
      return keyMatch[0] as ChainSlug;
    }

    const slugMatch = Object.entries(chainRegistry).find(([, meta]) => {
      return meta.slug && sanitize(meta.slug) === normalized;
    });
    if (slugMatch) {
      return slugMatch[0] as ChainSlug;
    }

    const asNumber = Number.parseInt(normalized, 10);
    if (!Number.isNaN(asNumber)) {
      const match = Object.entries(chainRegistry).find(([, meta]) => meta.id === asNumber);
      if (match) {
        return match[0] as ChainSlug;
      }
    }
  }

  throw new Error(\`Unknown chain reference: \${reference}\`);
}

export function getRpcUrl(chain: ChainSlug | number, options?: RpcProviderOptions): string {
  const slug = resolveChainSlug(chain);
  const entry = chainRegistry[slug];
  return entry.rpcUrl(options);
}

export function wallet(options: WalletPrivateKeyOptions): Promise<WalletFullContext>;
export function wallet(options: WalletTurnkeyOptions): Promise<WalletFullContext>;
export function wallet(options?: WalletReadonlyOptions): Promise<WalletReadonlyContext>;
export async function wallet(options: WalletOptions = {}): Promise<WalletContext> {
  if (options.privateKey && options.turnkey) {
    throw new Error("wallet() cannot be initialized with both privateKey and turnkey credentials");
  }

  const slug = resolveChainSlug(options.chain);
  const chain = chainRegistry[slug];
  const tokens = tokenRegistry[slug] ?? {};
  const overrides: RpcProviderOptions = {};
  if (options.rpcUrl) {
    overrides.url = options.rpcUrl;
  }
  if (options.apiKey) {
    overrides.apiKey = options.apiKey;
  }

  const rpcUrl = getRpcUrl(slug, overrides);

  let providerType: WalletProviderType = "readonly";
  let signerProvider:
    | ReturnType<typeof createPrivateKeyProvider>
    | (Awaited<ReturnType<typeof createTurnkeyProvider>>)
    | undefined;

  if (options.privateKey) {
    signerProvider = createPrivateKeyProvider({
      chain,
      rpcUrl,
      privateKey: options.privateKey,
    });
    providerType = "privateKey";
  } else if (options.turnkey) {
    const turnkeyConfig = {
      chain,
      rpcUrl,
      organizationId: options.turnkey.organizationId,
      apiPublicKey: options.turnkey.apiPublicKey,
      apiPrivateKey: options.turnkey.apiPrivateKey,
      signWith: options.turnkey.signWith,
    } as Parameters<typeof createTurnkeyProvider>[0];

    if (options.turnkey.apiBaseUrl) {
      turnkeyConfig.apiBaseUrl = options.turnkey.apiBaseUrl;
    }

    signerProvider = await createTurnkeyProvider(turnkeyConfig);
    providerType = "turnkey";
  }

  const publicClient = signerProvider?.publicClient ??
    createPublicClient({
      chain: chain.chain,
      transport: http(rpcUrl),
    });

  const baseContext: WalletReadonlyContext = {
    chain,
    tokens,
    rpcUrl,
    providerType,
    publicClient,
    getRpcUrl: (override?: RpcProviderOptions) => getRpcUrl(slug, override),
  };

  if (signerProvider) {
    const { publicClient: _ignored, ...rest } = signerProvider;
    return {
      ...baseContext,
      ...rest,
    } as WalletFullContext;
  }

  return baseContext;
}

export const walletToolkit = {
  chains: chainRegistry,
  tokens: tokenRegistry,
  registry: walletRegistry,
  defaults: {
    chain: DEFAULT_CHAIN,
    tokens: DEFAULT_TOKENS,
  },
  getRpcUrl,
  wallet,
} as const;
`,
  "src/wallets/providers/turnkey.ts": `import { Turnkey } from "@turnkey/sdk-server";
import { createAccount } from "@turnkey/viem";
import {
  createPublicClient,
  createWalletClient,
  http,
  type Chain,
  type PublicClient,
  type Transport,
} from "viem";
import type { Account } from "viem/accounts";

import type {
  ChainMetadata,
  HexAddress,
  TurnkeySignWith,
  WalletSignerContext,
  WalletSendTransactionParams,
  WalletTransferParams,
} from "../types";

export interface TurnkeyProviderConfig {
  chain: ChainMetadata;
  rpcUrl: string;
  organizationId: string;
  apiPublicKey: string;
  apiPrivateKey: string;
  signWith: TurnkeySignWith;
  apiBaseUrl?: string;
}

export interface TurnkeyProviderResult extends WalletSignerContext {
  publicClient: PublicClient<Transport, Chain>;
}

export async function createTurnkeyProvider(
  config: TurnkeyProviderConfig
): Promise<TurnkeyProviderResult> {
  const turnkey = new Turnkey({
    apiBaseUrl: config.apiBaseUrl ?? "https://api.turnkey.com",
    // The delegated sub-organization the API key pair belongs to.
    defaultOrganizationId: config.organizationId,
    apiPublicKey: config.apiPublicKey,
    apiPrivateKey: config.apiPrivateKey,
  });

  const account = (await createAccount({
    client: turnkey.apiClient(),
    organizationId: config.organizationId,
    signWith: config.signWith,
  })) as Account;

  const transport = http(config.rpcUrl);
  const publicClient = createPublicClient<Transport, Chain>({
    chain: config.chain.chain,
    transport,
  });

  const walletClient = createWalletClient<Transport, Chain, Account>({
    account,
    chain: config.chain.chain,
    transport,
  });

  async function sendTransaction(params: WalletSendTransactionParams) {
    const tx: any = {
      account,
    };
    if (params.to) {
      tx.to = params.to;
    }
    if (params.value !== undefined) {
      tx.value = params.value;
    }
    if (params.data !== undefined) {
      tx.data = params.data;
    }

    return walletClient.sendTransaction(tx);
  }

  async function getNativeBalance() {
    return publicClient.getBalance({ address: account.address });
  }

  async function transfer(params: WalletTransferParams) {
    return sendTransaction({
      to: params.to,
      value: params.amount,
      ...(params.data !== undefined ? { data: params.data } : {}),
    });
  }

  return {
    address: account.address as HexAddress,
    account,
    walletClient,
    publicClient,
    sendTransaction,
    getNativeBalance,
    transfer,
  };
}
`,
  "src/wallets/providers/private-key.ts": `import { createPublicClient, createWalletClient, http, type Chain, type PublicClient, type Transport } from "viem";
import { privateKeyToAccount, type Account } from "viem/accounts";

import type {
  ChainMetadata,
  HexAddress,
  WalletSignerContext,
  WalletSendTransactionParams,
  WalletTransferParams,
} from "../types";

function normalizePrivateKey(raw: string): \`0x\${string}\` {
  const trimmed = raw.trim();
  const withPrefix = trimmed.startsWith("0x") ? trimmed : \`0x\${trimmed}\`;
  if (!/^0x[0-9a-fA-F]{64}$/.test(withPrefix)) {
    throw new Error("wallet() privateKey must be a 32-byte hex string");
  }
  return withPrefix as \`0x\${string}\`;
}

export interface PrivateKeyProviderConfig {
  chain: ChainMetadata;
  rpcUrl: string;
  privateKey: string;
}

export interface PrivateKeyProviderResult extends WalletSignerContext {
  publicClient: PublicClient<Transport, Chain>;
}

export function createPrivateKeyProvider(
  config: PrivateKeyProviderConfig
): PrivateKeyProviderResult {
  const privateKey = normalizePrivateKey(config.privateKey);
  const account = privateKeyToAccount(privateKey);

  const transport = http(config.rpcUrl);
  const publicClient = createPublicClient<Transport, Chain>({
    chain: config.chain.chain,
    transport,
  });

  const walletClient = createWalletClient<Transport, Chain, Account>({
    account,
    chain: config.chain.chain,
    transport,
  });

  async function sendTransaction(params: WalletSendTransactionParams) {
    const tx: any = {
      account,
    };
    if (params.to) {
      tx.to = params.to;
    }
    if (params.value !== undefined) {
      tx.value = params.value;
    }
    if (params.data !== undefined) {
      tx.data = params.data;
    }

    return walletClient.sendTransaction(tx);
  }

  async function getNativeBalance() {
    return publicClient.getBalance({ address: account.address });
  }

  async function transfer(params: WalletTransferParams) {
    return sendTransaction({
      to: params.to,
      value: params.amount,
      ...(params.data !== undefined ? { data: params.data } : {}),
    });
  }

  return {
    address: account.address as HexAddress,
    account,
    walletClient,
    publicClient,
    sendTransaction,
    getNativeBalance,
    transfer,
  };
}
`,
  "src/wallets/turnkey.ts": `export interface TurnkeyCredentials {
  organizationId: string;
  apiPublicKey: string;
  apiPrivateKey: string;
  apiBaseUrl?: string;
}

export interface TurnkeyWalletConfig extends TurnkeyCredentials {
  walletId?: string;
}

// Placeholder implementation to be replaced in the wallet integration work.
export function createTurnkeyWalletClient(_config: TurnkeyWalletConfig) {
  throw new Error("Turnkey wallet support is not implemented yet");
}
`,
  "src/wallets/types.ts": `import type { Chain, PublicClient, Transport, WalletClient } from "viem";
import type { Account } from "viem/accounts";

export type Hex = \`0x\${string}\`;
export type HexAddress = \`0x\${string}\`;

export interface RpcProviderOptions {
  /** Optional fully-qualified RPC URL override. */
  url?: string;
  /** Provider API key to interpolate into hosted RPC templates. */
  apiKey?: string;
}

export type RpcUrlResolver = (options?: RpcProviderOptions) => string;

export interface ChainMetadata {
  id: number;
  slug: string;
  name: string;
  chain: Chain;
  rpcUrl: RpcUrlResolver;
  publicRpcUrls?: readonly string[];
}

export interface TokenMetadata {
  symbol: string;
  name: string;
  decimals: number;
  address: HexAddress;
  chainId: number;
  isNative?: boolean;
}

export type ChainTokenMap = Record<string, TokenMetadata>;

export interface WalletRegistry {
  chains: Record<string, ChainMetadata>;
  tokens: Record<string, ChainTokenMap>;
}

export type ChainReference = string | number;

export type WalletProviderType = "readonly" | "privateKey" | "turnkey";

export type TurnkeySignWith = string;

export interface TurnkeyOptions {
  organizationId: string;
  apiPublicKey: string;
  apiPrivateKey: string;
  /** Identifier of the delegated signer (Turnkey address or private key ID). */
  signWith: TurnkeySignWith;
  apiBaseUrl?: string;
}

export interface WalletOptionsBase {
  chain?: ChainReference;
  apiKey?: string;
  rpcUrl?: string;
}

export interface WalletPrivateKeyOptions extends WalletOptionsBase {
  privateKey: string;
  turnkey?: undefined;
}

export interface WalletTurnkeyOptions extends WalletOptionsBase {
  privateKey?: undefined;
  turnkey: TurnkeyOptions;
}

export type WalletReadonlyOptions = WalletOptionsBase & {
  privateKey?: undefined;
  turnkey?: undefined;
};

export type WalletOptions =
  | WalletReadonlyOptions
  | WalletPrivateKeyOptions
  | WalletTurnkeyOptions;

export interface WalletSendTransactionParams {
  to?: HexAddress;
  value?: bigint;
  data?: Hex;
}

export interface WalletTransferParams {
  to: HexAddress;
  amount: bigint;
  data?: Hex;
}

export interface WalletSignerContext {
  address: HexAddress;
  account: Account;
  walletClient: WalletClient<Transport, Chain, Account>;
  publicClient: PublicClient<Transport, Chain>;
  sendTransaction(params: WalletSendTransactionParams): Promise<Hex>;
  getNativeBalance(): Promise<bigint>;
  transfer(params: WalletTransferParams): Promise<Hex>;
}

export interface WalletBaseContext {
  chain: ChainMetadata;
  rpcUrl: string;
  tokens: ChainTokenMap;
  providerType: WalletProviderType;
  publicClient: PublicClient;
  getRpcUrl(options?: RpcProviderOptions): string;
}

export type WalletReadonlyContext = WalletBaseContext;
export type WalletFullContext = WalletBaseContext & WalletSignerContext;
export type WalletContext = WalletReadonlyContext | WalletFullContext;
`,
};

/**
 * Get formatted context prompt for AI code generation
 *
 * This function returns a comprehensive prompt containing all opentool
 * documentation, working examples, and source code that an AI model
 * should use as authoritative reference when generating opentool code.
 */
export function getOpenToolContext(): string {
  const sections: string[] = [];

  sections.push("# OPENTOOL FRAMEWORK - COMPLETE DOCUMENTATION AND SOURCE");
  sections.push("");
  sections.push("You have access to the complete opentool v" + OPENTOOL_VERSION + " framework.");
  sections.push("This includes documentation, working examples, and source code.");
  sections.push("Use these as your AUTHORITATIVE reference. Follow the patterns EXACTLY.");
  sections.push("");

  sections.push("## README.md - Framework Overview");
  sections.push("");
  sections.push(OPENTOOL_README);
  sections.push("");

  sections.push("## METADATA.md - Metadata and Payment System");
  sections.push("");
  sections.push(OPENTOOL_METADATA_GUIDE);
  sections.push("");

  sections.push("## WORKING EXAMPLES FROM PRODUCTION");
  sections.push("");
  sections.push("These are real, tested, working examples from the opentool repository.");
  sections.push("Follow these patterns EXACTLY when generating code.");
  sections.push("");

  for (const [filename, content] of Object.entries(OPENTOOL_EXAMPLES)) {
    sections.push(`### examples/full-metadata/tools/${filename}`);
    sections.push("\`\`\`typescript");
    sections.push(content);
    sections.push("\`\`\`");
    sections.push("");
  }

  sections.push("## WALLET API SOURCE CODE");
  sections.push("");
  sections.push("Complete wallet implementation showing exact function signatures, types, and usage.");
  sections.push("THIS IS THE AUTHORITATIVE API - use exactly as shown here.");
  sections.push("");

  for (const [filename, content] of Object.entries(OPENTOOL_WALLET_SOURCE)) {
    sections.push(`### ${filename}`);
    sections.push("\`\`\`typescript");
    sections.push(content);
    sections.push("\`\`\`");
    sections.push("");
  }

  sections.push("## KEY PATTERNS TO FOLLOW");
  sections.push("");
  sections.push("### Wallet Usage (CORRECT):");
  sections.push("\`\`\`typescript");
  sections.push("import { wallet } from 'opentool/wallet';");
  sections.push("");
  sections.push("const context = await wallet({");
  sections.push("  chain: 'base-sepolia',");
  sections.push("  apiKey: process.env.ALCHEMY_API_KEY,");
  sections.push("  turnkey: {");
  sections.push("    organizationId: process.env.TURNKEY_SUBORG_ID!,");
  sections.push("    apiPublicKey: process.env.TURNKEY_API_PUBLIC_KEY!,");
  sections.push("    apiPrivateKey: process.env.TURNKEY_API_PRIVATE_KEY!,");
  sections.push("    signWith: process.env.TURNKEY_WALLET_ADDRESS as `0x${string}`,");
  sections.push("  },");
  sections.push("});");
  sections.push("");
  sections.push("const balance = await context.getNativeBalance();");
  sections.push("const txHash = await context.transfer({ to, amount });");
  sections.push("\`\`\`");
  sections.push("");
  sections.push("### HTTP Handler Pattern:");
  sections.push("\`\`\`typescript");
  sections.push("import { z } from 'zod';");
  sections.push("");
  sections.push("export const schema = z.object({");
  sections.push("  // input parameters");
  sections.push("});");
  sections.push("");
  sections.push("export const metadata = {");
  sections.push("  name: 'tool-name',");
  sections.push("  description: 'Tool description',");
  sections.push("};");
  sections.push("");
  sections.push("export async function POST(request: Request) {");
  sections.push("  const payload = await request.json();");
  sections.push("  const params = schema.parse(payload);");
  sections.push("  ");
  sections.push("  // implement tool logic");
  sections.push("  ");
  sections.push("  return Response.json({ result: 'success' });");
  sections.push("}");
  sections.push("\`\`\`");
  sections.push("");

  return sections.join("\n");
}
