{"version":3,"sources":["../../src/ai/errors.ts","../../src/ai/config.ts","../../src/ai/models.ts","../../src/ai/tools.ts","../../src/ai/messages.ts","../../src/ai/client.ts"],"names":["payload"],"mappings":"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","file":"index.js","sourcesContent":["interface ErrorInit {\n  cause?: unknown;\n}\n\nexport class AIError extends Error {\n  constructor(message: string, options?: ErrorInit) {\n    super(message);\n    this.name = \"AIError\";\n    if (options && \"cause\" in options) {\n      (this as unknown as { cause?: unknown }).cause = options.cause;\n    }\n  }\n}\n\nexport interface ResponseErrorDetails {\n  status: number;\n  statusText: string;\n  body?: unknown;\n  headers?: Record<string, string>;\n}\n\nexport class AIFetchError extends AIError {\n  constructor(message: string, options?: ErrorInit) {\n    super(message, options);\n    this.name = \"AIFetchError\";\n  }\n}\n\nexport class AIResponseError extends AIError {\n  readonly status: number;\n  readonly statusText: string;\n  readonly body?: unknown;\n  readonly headers: Record<string, string>;\n\n  constructor(details: ResponseErrorDetails, message?: string) {\n    super(message ?? `AI response error: ${details.status} ${details.statusText}`);\n    this.name = \"AIResponseError\";\n    this.status = details.status;\n    this.statusText = details.statusText;\n    this.body = details.body;\n    this.headers = details.headers ?? {};\n  }\n}\n\nexport class AIAbortError extends AIError {\n  constructor(message = \"AI request aborted\") {\n    super(message);\n    this.name = \"AIAbortError\";\n  }\n}\n","import { AIClientConfig, ResolvedAIClientConfig } from \"./types\";\n\nexport const DEFAULT_BASE_URL = \"https://gateway.openpond.dev\";\nexport const DEFAULT_TIMEOUT_MS = 60_000;\nexport const DEFAULT_MODEL = \"openai/gpt-5-mini\";\n\nfunction assertFetchAvailable(fetchImplementation?: typeof fetch): asserts fetchImplementation {\n  if (!fetchImplementation) {\n    throw new Error(\n      \"No fetch implementation available. Provide one via AIClientConfig.fetchImplementation.\"\n    );\n  }\n}\n\nexport function resolveConfig(\n  config: AIClientConfig = {}\n): ResolvedAIClientConfig {\n  const fetchImplementation = config.fetchImplementation ?? globalThis.fetch;\n  assertFetchAvailable(fetchImplementation);\n\n  const resolved: ResolvedAIClientConfig = {\n    baseUrl: config.baseUrl ?? DEFAULT_BASE_URL,\n    defaultModel: config.defaultModel ?? DEFAULT_MODEL,\n    defaultHeaders: {\n      \"Content-Type\": \"application/json\",\n      ...config.defaultHeaders,\n    },\n    fetchImplementation,\n    timeoutMs: config.timeoutMs ?? DEFAULT_TIMEOUT_MS,\n  };\n\n  if (config.apiKey !== undefined) {\n    resolved.apiKey = config.apiKey;\n  }\n\n  return resolved;\n}\n\nexport function mergeHeaders(\n  base: Record<string, string>,\n  overrides?: Record<string, string>\n): Record<string, string> {\n  if (!overrides) {\n    return { ...base };\n  }\n\n  const merged = { ...base };\n  for (const [key, value] of Object.entries(overrides)) {\n    if (value === undefined) {\n      continue;\n    }\n\n    merged[key] = value;\n  }\n  return merged;\n}\n","export type ModelProvider = \"openai\" | \"anthropic\" | \"google\" | \"deepseek\" | \"custom\";\n\nexport interface ModelConfig {\n  name: string;\n  label: string;\n  provider: ModelProvider;\n  supportsStreaming: boolean;\n  supportsTools: boolean;\n  reasoning?: boolean;\n  aliases?: string[];\n  default?: boolean;\n}\n\nconst MODEL_REGISTRY: ModelConfig[] = [\n  {\n    name: \"openai/gpt-5-mini\",\n    label: \"OpenAI GPT-5 Mini\",\n    provider: \"openai\",\n    supportsStreaming: true,\n    supportsTools: true,\n    reasoning: true,\n    aliases: [\"gpt-5-mini\", \"gpt5-mini\", \"gpt-5.0-mini\"],\n    default: true,\n  },\n  {\n    name: \"anthropic/claude-4-sonnet-20250514\",\n    label: \"Claude 4 Sonnet (20250514)\",\n    provider: \"anthropic\",\n    supportsStreaming: true,\n    supportsTools: true,\n    aliases: [\"claude-4-sonnet\", \"claude-sonnet\"],\n  },\n  {\n    name: \"google/gemini-2.0-flash-001\",\n    label: \"Gemini 2.0 Flash\",\n    provider: \"google\",\n    supportsStreaming: true,\n    supportsTools: true,\n    aliases: [\"gemini-2.0-flash\", \"gemini-flash\"],\n  },\n  {\n    name: \"deepseek/deepseek-chat\",\n    label: \"DeepSeek Chat\",\n    provider: \"deepseek\",\n    supportsStreaming: true,\n    supportsTools: true,\n    aliases: [\"deepseek-chat\", \"deepseek\"],\n  },\n];\n\nconst ALIAS_LOOKUP: Record<string, string> = MODEL_REGISTRY.reduce(\n  (accumulator, model) => {\n    accumulator[model.name.toLowerCase()] = model.name;\n    if (model.aliases) {\n      for (const alias of model.aliases) {\n        accumulator[alias.toLowerCase()] = model.name;\n      }\n    }\n    return accumulator;\n  },\n  {} as Record<string, string>\n);\n\nconst DEFAULT_MODEL_NAME =\n  MODEL_REGISTRY.find((model) => model.default)?.name ?? MODEL_REGISTRY[0].name;\n\nexport function listModels(): ModelConfig[] {\n  return [...MODEL_REGISTRY];\n}\n\nexport function getModelConfig(modelName?: string): ModelConfig | undefined {\n  if (!modelName) {\n    return MODEL_REGISTRY.find((model) => model.default) ?? MODEL_REGISTRY[0];\n  }\n\n  const normalized = normalizeModelName(modelName);\n  return MODEL_REGISTRY.find((model) => model.name === normalized);\n}\n\nexport function normalizeModelName(modelName?: string): string {\n  if (!modelName) {\n    return DEFAULT_MODEL_NAME;\n  }\n\n  const trimmed = modelName.trim();\n  if (!trimmed) {\n    return DEFAULT_MODEL_NAME;\n  }\n\n  const directMatch = ALIAS_LOOKUP[trimmed.toLowerCase()];\n  if (directMatch) {\n    return directMatch;\n  }\n\n  if (trimmed.includes(\"/\")) {\n    return trimmed;\n  }\n\n  return `openai/${trimmed}`;\n}\n\nexport function isStreamingSupported(modelName?: string): boolean {\n  const config = getModelConfig(modelName);\n  return config ? config.supportsStreaming : true;\n}\n\nexport function isToolCallingSupported(modelName?: string): boolean {\n  const config = getModelConfig(modelName);\n  return config ? config.supportsTools : true;\n}\n\n","import {\n  ToolDefinition,\n  ToolExecutionPolicy,\n  WebSearchOptions,\n} from \"./types\";\n\nexport const WEBSEARCH_TOOL_NAME = \"websearch\";\n\nexport const WEBSEARCH_TOOL_DEFINITION: ToolDefinition = {\n  type: \"function\",\n  function: {\n    name: WEBSEARCH_TOOL_NAME,\n    description:\n      \"Search the web using the OpenPond search engine. Returns relevant results with titles, URLs, and text content.\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        query: {\n          type: \"string\",\n          description: \"The search query\",\n        },\n        limit: {\n          type: \"number\",\n          description: \"Maximum number of results to return (default: 5)\",\n        },\n      },\n      required: [\"query\"],\n    },\n  },\n};\n\nexport function resolveToolset(\n  tools: ToolDefinition[] | undefined,\n  policy: ToolExecutionPolicy | undefined\n): ToolDefinition[] | undefined {\n  if (!policy) {\n    return tools;\n  }\n\n  const resolved: ToolDefinition[] = tools ? [...tools] : [];\n\n  if (policy.webSearch) {\n    const alreadyIncluded = resolved.some(\n      (tool) =>\n        tool.type === \"function\" && tool.function?.name === WEBSEARCH_TOOL_NAME\n    );\n    if (!alreadyIncluded) {\n      resolved.push(materializeWebSearchTool(policy.webSearch));\n    }\n  }\n\n  return resolved.length > 0 ? resolved : undefined;\n}\n\nfunction materializeWebSearchTool(options: WebSearchOptions): ToolDefinition {\n  if (!options || Object.keys(options).length === 0) {\n    return WEBSEARCH_TOOL_DEFINITION;\n  }\n\n  const baseParameters =\n    WEBSEARCH_TOOL_DEFINITION.function.parameters ??\n    ({} as Record<string, unknown>);\n  const baseProperties =\n    (baseParameters.properties as Record<string, unknown> | undefined) ?? {};\n\n  const properties: Record<string, unknown> = { ...baseProperties };\n\n  if (options.limit !== undefined) {\n    const existingLimit = baseProperties[\"limit\"];\n    const limitSchema: Record<string, unknown> =\n      typeof existingLimit === \"object\" && existingLimit !== null\n        ? { ...(existingLimit as Record<string, unknown>) }\n        : {\n            type: \"number\",\n            description:\n              \"Maximum number of results to return (default: 5)\",\n          };\n\n    limitSchema.default = options.limit;\n    properties.limit = limitSchema;\n  }\n\n  if (options.includeImages) {\n    properties.includeImages = {\n      type: \"boolean\",\n      description: \"Whether to include representative images in results.\",\n      default: true,\n    };\n  }\n\n  return {\n    ...WEBSEARCH_TOOL_DEFINITION,\n    function: {\n      ...WEBSEARCH_TOOL_DEFINITION.function,\n      parameters: {\n        ...WEBSEARCH_TOOL_DEFINITION.function.parameters,\n        properties,\n      },\n    },\n  } as ToolDefinition;\n}\n","import { AIError } from \"./errors\";\nimport { ChatMessage, ChatMessageContentPart } from \"./types\";\n\nexport interface FlattenMessageContentOptions {\n  /**\n   * String used to join individual text segments when the content array contains multiple text parts.\n   * Defaults to an empty string.\n   */\n  separator?: string;\n  /**\n   * When true, JSON stringifies non-text segments instead of discarding them.\n   * Defaults to false (skip non-text parts).\n   */\n  includeUnknown?: boolean;\n}\n\nexport function flattenMessageContent(\n  content: ChatMessage[\"content\"],\n  options: FlattenMessageContentOptions = {}\n): string | undefined {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  if (!Array.isArray(content)) {\n    return undefined;\n  }\n\n  const separator = options.separator ?? \"\";\n  const collected: string[] = [];\n\n  for (const part of content) {\n    const text = extractTextPart(part, options);\n    if (text) {\n      collected.push(text);\n    }\n  }\n\n  if (collected.length === 0) {\n    return undefined;\n  }\n\n  return collected.join(separator);\n}\n\nexport interface EnsureTextContentOptions extends FlattenMessageContentOptions {\n  errorMessage?: string;\n}\n\nexport function ensureTextContent(\n  message: ChatMessage,\n  options?: EnsureTextContentOptions\n): string {\n  const flattened = flattenMessageContent(message.content, options);\n  if (flattened !== undefined) {\n    return flattened;\n  }\n\n  throw new AIError(\n    options?.errorMessage ??\n      \"Assistant response did not contain textual content.\"\n  );\n}\n\nfunction extractTextPart(\n  part: ChatMessageContentPart,\n  options: FlattenMessageContentOptions\n): string | undefined {\n  if (!part || typeof part !== \"object\") {\n    return undefined;\n  }\n\n  if (\"text\" in part && typeof part.text === \"string\") {\n    return part.text;\n  }\n\n  if (options.includeUnknown) {\n    try {\n      return JSON.stringify(part);\n    } catch (error) {\n      return `[unserializable_part: ${String(error)}]`;\n    }\n  }\n\n  return undefined;\n}\n","import { resolveConfig, mergeHeaders } from \"./config\";\nimport {\n  GenerateTextOptions,\n  GenerateTextResult,\n  AIClientConfig,\n  ChatCompletionResponse,\n  ChatCompletionChoice,\n  ChatCompletionUsage,\n  ResolvedAIClientConfig,\n  StreamTextOptions,\n  StreamTextResult,\n  GenerationParameters,\n  AIRequestMetadata,\n  ChatMessage,\n  StreamingEventHandlers,\n} from \"./types\";\nimport {\n  normalizeModelName,\n  isToolCallingSupported,\n  listModels,\n} from \"./models\";\nimport { resolveToolset } from \"./tools\";\nimport { flattenMessageContent } from \"./messages\";\nimport { AIFetchError, AIResponseError, AIAbortError, AIError } from \"./errors\";\n\nconst CHAT_COMPLETIONS_PATH = \"/v1/chat/completions\";\n\nexport interface AIClient {\n  readonly config: ResolvedAIClientConfig;\n  generateText(options: GenerateTextOptions): Promise<GenerateTextResult>;\n  streamText(options: StreamTextOptions): Promise<StreamTextResult>;\n  listModels: typeof listModels;\n}\n\ninterface ChatCompletionRequestPayload {\n  model: string;\n  messages: GenerateTextOptions[\"messages\"];\n  temperature?: number;\n  top_p?: number;\n  max_tokens?: number;\n  stop?: string | string[];\n  presence_penalty?: number;\n  frequency_penalty?: number;\n  tool_choice?: GenerateTextOptions[\"toolChoice\"];\n  tools?: GenerateTextOptions[\"tools\"];\n  stream?: boolean;\n  response_format?: GenerationParameters[\"responseFormat\"];\n  metadata?: Record<string, unknown>;\n  stream_options?: {\n    include_usage?: boolean;\n  };\n}\n\ninterface AbortBundle {\n  signal: AbortSignal;\n  abort: () => void;\n  cleanup: () => void;\n}\n\nexport function createAIClient(config: AIClientConfig = {}): AIClient {\n  const resolved = resolveConfig(config);\n\n  return {\n    get config() {\n      return resolved;\n    },\n    async generateText(options) {\n      return generateText(options, config);\n    },\n    async streamText(options) {\n      return streamText(options, config);\n    },\n    listModels,\n  };\n}\n\nexport async function generateText(\n  options: GenerateTextOptions,\n  clientConfig: AIClientConfig = {}\n): Promise<GenerateTextResult> {\n  const resolved = resolveConfig(clientConfig);\n  const model = normalizeModelName(options.model ?? resolved.defaultModel);\n\n  const payload = buildRequestPayload(options, model, {\n    allowTools: isToolCallingSupported(model),\n  });\n\n  const headers = mergeHeaders(resolved.defaultHeaders, options.headers);\n  if (resolved.apiKey) {\n    headers.Authorization = `Bearer ${resolved.apiKey}`;\n  }\n\n  const endpoint = buildUrl(resolved.baseUrl, CHAT_COMPLETIONS_PATH);\n  const abortBundle = createAbortBundle(\n    options.abortSignal,\n    options.timeoutMs ?? resolved.timeoutMs\n  );\n\n  let response: Response;\n  try {\n    response = await resolved.fetchImplementation(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(payload),\n      signal: abortBundle.signal,\n    });\n  } catch (error) {\n    if (abortBundle.signal.aborted) {\n      throw toAbortError(abortBundle.signal.reason ?? error);\n    }\n\n    throw new AIFetchError(\"Failed to reach AI gateway\", { cause: error });\n  } finally {\n    abortBundle.cleanup();\n  }\n\n  if (!response.ok) {\n    const errorBody = await safeParseJson(response);\n    throw new AIResponseError({\n      status: response.status,\n      statusText: response.statusText,\n      body: errorBody,\n      headers: collectHeaders(response.headers),\n    });\n  }\n\n  const data = (await response.json()) as ChatCompletionResponse;\n  const primaryChoice = data.choices.find(isPrimaryChoice);\n\n  if (!primaryChoice) {\n    throw new AIResponseError(\n      {\n        status: response.status,\n        statusText: response.statusText,\n        body: data,\n      },\n      \"Gateway response did not contain a valid choice\"\n    );\n  }\n\n  const result: GenerateTextResult = {\n    id: data.id,\n    model: data.model,\n    message: primaryChoice.message,\n    raw: data,\n  };\n\n  if (primaryChoice.finish_reason !== undefined) {\n    result.finishReason = primaryChoice.finish_reason;\n  }\n\n  if (data.usage) {\n    result.usage = data.usage;\n  }\n\n  return result;\n}\n\nexport async function streamText(\n  options: StreamTextOptions,\n  clientConfig: AIClientConfig = {}\n): Promise<StreamTextResult> {\n  const resolved = resolveConfig(clientConfig);\n  const model = normalizeModelName(options.model ?? resolved.defaultModel);\n\n  const streamExtras = buildStreamMetadataExtras(options);\n  const payload = buildRequestPayload(\n    options,\n    model,\n    {\n      allowTools: isToolCallingSupported(model),\n    },\n    streamExtras\n  );\n\n  payload.stream = true;\n  if (options.includeUsage) {\n    payload.stream_options = { include_usage: true };\n  }\n\n  const headers = mergeHeaders(resolved.defaultHeaders, options.headers);\n  if (resolved.apiKey) {\n    headers.Authorization = `Bearer ${resolved.apiKey}`;\n  }\n\n  const endpoint = buildUrl(resolved.baseUrl, CHAT_COMPLETIONS_PATH);\n  const abortBundle = createAbortBundle(\n    options.abortSignal,\n    options.timeoutMs ?? resolved.timeoutMs\n  );\n\n  let response: Response;\n  try {\n    response = await resolved.fetchImplementation(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(payload),\n      signal: abortBundle.signal,\n    });\n  } catch (error) {\n    if (abortBundle.signal.aborted) {\n      throw toAbortError(abortBundle.signal.reason ?? error);\n    }\n\n    throw new AIFetchError(\"Failed to reach AI gateway\", { cause: error });\n  }\n\n  if (!response.ok) {\n    const errorBody = await safeParseJson(response);\n    abortBundle.cleanup();\n    throw new AIResponseError({\n      status: response.status,\n      statusText: response.statusText,\n      body: errorBody,\n      headers: collectHeaders(response.headers),\n    });\n  }\n\n  if (!response.body) {\n    abortBundle.cleanup();\n    throw new AIFetchError(\"Streaming response did not include a readable body\");\n  }\n\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  const handlers = options.handlers ?? {};\n\n  let finishedResolve: () => void;\n  let finishedReject: (reason?: unknown) => void;\n  const finished = new Promise<void>((resolve, reject) => {\n    finishedResolve = resolve;\n    finishedReject = reject;\n  });\n\n  let settled = false;\n\n  const resolveStream = () => {\n    if (settled) {\n      return;\n    }\n    settled = true;\n    try {\n      handlers.onDone?.();\n      finishedResolve();\n    } catch (error) {\n      settled = false; // allow rejectError to run with handler error\n      rejectStream(error);\n    }\n  };\n\n  const rejectStream = (reason: unknown) => {\n    if (settled) {\n      return;\n    }\n    settled = true;\n    try {\n      handlers.onError?.(reason);\n    } catch (handlerError) {\n      reason = handlerError;\n    }\n    finishedReject(reason);\n  };\n\n  const abort = () => abortBundle.abort();\n\n  (async () => {\n    let buffer = \"\";\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          buffer += decoder.decode();\n          buffer = buffer.replace(/\\r\\n/g, \"\\n\");\n          if (buffer.trim().length > 0) {\n            if (processStreamEventChunk(buffer, handlers)) {\n              break;\n            }\n          }\n          resolveStream();\n          break;\n        }\n\n        buffer += decoder.decode(value, { stream: true });\n        buffer = buffer.replace(/\\r\\n/g, \"\\n\");\n\n        let boundaryIndex: number;\n        while ((boundaryIndex = buffer.indexOf(\"\\n\\n\")) !== -1) {\n          const chunk = buffer.slice(0, boundaryIndex);\n          buffer = buffer.slice(boundaryIndex + 2);\n          if (!chunk) {\n            continue;\n          }\n          if (processStreamEventChunk(chunk, handlers)) {\n            await reader.cancel().catch(() => undefined);\n            resolveStream();\n            return;\n          }\n        }\n      }\n    } catch (error) {\n      if (abortBundle.signal.aborted) {\n        rejectStream(toAbortError(abortBundle.signal.reason ?? error));\n      } else {\n        rejectStream(error);\n      }\n    } finally {\n      try {\n        reader.releaseLock();\n      } catch (error) {\n        // ignore release errors\n      }\n      abortBundle.cleanup();\n    }\n  })().catch((error) => {\n    rejectStream(error);\n  });\n\n  return {\n    abort,\n    finished,\n  };\n\n  function processStreamEventChunk(\n    chunk: string,\n    eventHandlers: StreamingEventHandlers\n  ): boolean {\n    const dataString = extractSseData(chunk);\n    if (dataString == null) {\n      return false;\n    }\n\n    const trimmed = dataString.trim();\n    if (trimmed === \"[DONE]\") {\n      return true;\n    }\n\n    let payload: unknown;\n    try {\n      payload = JSON.parse(dataString);\n    } catch (error) {\n      rejectStream(new AIError(\"Failed to parse streaming payload\", { cause: error }));\n      return true;\n    }\n\n    try {\n      handleStreamPayload(payload, eventHandlers);\n    } catch (error) {\n      rejectStream(error);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleStreamPayload(\n    payload: unknown,\n    eventHandlers: StreamingEventHandlers\n  ): void {\n    if (!payload || typeof payload !== \"object\") {\n      return;\n    }\n\n    if (\"error\" in payload && payload.error) {\n      const message =\n        typeof payload.error === \"string\"\n          ? payload.error\n          : (payload.error as { message?: string }).message;\n      throw new AIError(message ?? \"AI stream returned an error payload\");\n    }\n\n    const structured = payload as {\n      choices?: Array<{ delta?: unknown }>;\n      usage?: ChatCompletionUsage;\n    };\n\n    if (Array.isArray(structured.choices)) {\n      for (const choice of structured.choices) {\n        if (!choice || typeof choice !== \"object\") {\n          continue;\n        }\n        const delta = (choice as { delta?: unknown }).delta;\n        if (!delta || typeof delta !== \"object\") {\n          continue;\n        }\n        const deltaObject = delta as Record<string, unknown>;\n\n        const textDelta = extractDeltaText(deltaObject.content);\n        if (textDelta) {\n          eventHandlers.onTextDelta?.(textDelta);\n        }\n\n        const reasoningDelta = extractDeltaText(deltaObject.reasoning);\n        if (reasoningDelta) {\n          eventHandlers.onReasoningDelta?.(reasoningDelta);\n        }\n\n        if (deltaObject.tool_calls !== undefined) {\n          eventHandlers.onToolCallDelta?.(deltaObject.tool_calls);\n        }\n      }\n    }\n\n    if (structured.usage) {\n      eventHandlers.onUsage?.(structured.usage);\n    }\n  }\n\n  function extractDeltaText(value: unknown): string | undefined {\n    if (!value) {\n      return undefined;\n    }\n\n    if (typeof value === \"string\") {\n      return value;\n    }\n\n    if (Array.isArray(value)) {\n      return flattenMessageContent(value as ChatMessage[\"content\"]);\n    }\n\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      \"content\" in value &&\n      Array.isArray((value as { content?: unknown }).content)\n    ) {\n      return flattenMessageContent(\n        ((value as { content?: ChatMessage[\"content\"] }).content ?? []) as ChatMessage[\"content\"]\n      );\n    }\n\n    return undefined;\n  }\n\n  function extractSseData(chunk: string): string | null {\n    const lines = chunk.split(\"\\n\");\n    const dataLines: string[] = [];\n    for (const rawLine of lines) {\n      if (!rawLine) {\n        continue;\n      }\n      const match = /^data:(.*)$/.exec(rawLine);\n      if (!match) {\n        continue;\n      }\n\n      const value = match[1];\n      dataLines.push(value.startsWith(\" \") ? value.slice(1) : value);\n    }\n\n    if (dataLines.length === 0) {\n      return null;\n    }\n\n    return dataLines.join(\"\\n\");\n  }\n}\n\nfunction buildStreamMetadataExtras(\n  options: StreamTextOptions\n): Record<string, unknown> | undefined {\n  const streamConfig: Record<string, unknown> = {};\n\n  if (options.sendReasoning !== undefined) {\n    streamConfig.sendReasoning = options.sendReasoning;\n  }\n\n  if (options.includeUsage !== undefined) {\n    streamConfig.includeUsage = options.includeUsage;\n  }\n\n  if (Object.keys(streamConfig).length === 0) {\n    return undefined;\n  }\n\n  return {\n    openpond: {\n      stream: streamConfig,\n    },\n  } satisfies Record<string, unknown>;\n}\n\nfunction buildRequestPayload(\n  options: GenerateTextOptions,\n  model: string,\n  capabilities: { allowTools: boolean },\n  metadataExtras?: Record<string, unknown>\n): ChatCompletionRequestPayload {\n  const payload: ChatCompletionRequestPayload = {\n    model,\n    messages: options.messages,\n  };\n\n  const generation: GenerationParameters = options.generation ?? {};\n\n  assignIfDefined(payload, \"temperature\", generation.temperature);\n  assignIfDefined(payload, \"top_p\", generation.topP);\n  assignIfDefined(payload, \"max_tokens\", generation.maxTokens);\n  assignIfDefined(payload, \"stop\", generation.stop);\n  assignIfDefined(\n    payload,\n    \"frequency_penalty\",\n    generation.frequencyPenalty\n  );\n  assignIfDefined(payload, \"presence_penalty\", generation.presencePenalty);\n  assignIfDefined(payload, \"response_format\", generation.responseFormat);\n\n  const toolExecution = options.toolExecution;\n  const enableTools = toolExecution?.enableTools ?? true;\n  if (enableTools && capabilities.allowTools) {\n    const resolvedTools = resolveToolset(options.tools, toolExecution);\n    assignIfDefined(payload, \"tools\", resolvedTools);\n    assignIfDefined(payload, \"tool_choice\", options.toolChoice);\n  } else if (options.toolChoice && options.toolChoice !== \"none\") {\n    payload.tool_choice = \"none\";\n  }\n\n  const metadataPayload = buildMetadataPayload(\n    options.metadata,\n    toolExecution,\n    metadataExtras\n  );\n  if (metadataPayload) {\n    payload.metadata = metadataPayload;\n  }\n\n  return payload;\n}\n\nfunction assignIfDefined<T extends object, K extends keyof T>(\n  target: T,\n  key: K,\n  value: T[K] | undefined\n): void {\n  if (value !== undefined) {\n    target[key] = value;\n  }\n}\n\nfunction buildUrl(baseUrl: string, path: string): string {\n  const sanitizedBase = baseUrl.endsWith(\"/\")\n    ? baseUrl.slice(0, -1)\n    : baseUrl;\n  return `${sanitizedBase}${path}`;\n}\n\nfunction createAbortBundle(\n  upstreamSignal: AbortSignal | undefined,\n  timeoutMs: number | undefined\n): AbortBundle {\n  const controller = new AbortController();\n  const cleanupCallbacks: Array<() => void> = [];\n\n  if (upstreamSignal) {\n    if (upstreamSignal.aborted) {\n      controller.abort(upstreamSignal.reason);\n    } else {\n      const onAbort = () => controller.abort(upstreamSignal.reason);\n      upstreamSignal.addEventListener(\"abort\", onAbort, { once: true });\n      cleanupCallbacks.push(() =>\n        upstreamSignal.removeEventListener(\"abort\", onAbort)\n      );\n    }\n  }\n\n  if (timeoutMs && timeoutMs > 0) {\n    const timeoutId = setTimeout(() => {\n      controller.abort(new Error(\"AI request timed out\"));\n    }, timeoutMs);\n    cleanupCallbacks.push(() => clearTimeout(timeoutId));\n  }\n\n  return {\n    signal: controller.signal,\n    abort: () => controller.abort(),\n    cleanup: () => {\n      cleanupCallbacks.forEach((fn) => fn());\n    },\n  };\n}\n\nfunction collectHeaders(headers: Headers): Record<string, string> {\n  const result: Record<string, string> = {};\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\n\nfunction buildMetadataPayload(\n  base: AIRequestMetadata | undefined,\n  toolExecution: GenerateTextOptions[\"toolExecution\"] | undefined,\n  extras?: Record<string, unknown>\n): Record<string, unknown> | undefined {\n  const metadata: Record<string, unknown> = base ? { ...base } : {};\n\n  if (extras) {\n    for (const [key, value] of Object.entries(extras)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      if (key === \"openpond\" && typeof value === \"object\" && value !== null) {\n        const existing = {\n          ...((metadata.openpond as Record<string, unknown> | undefined) ?? {}),\n        };\n        metadata.openpond = {\n          ...existing,\n          ...(value as Record<string, unknown>),\n        };\n      } else {\n        metadata[key] = value;\n      }\n    }\n  }\n\n  if (toolExecution) {\n    const openpond = {\n      ...((metadata.openpond as Record<string, unknown> | undefined) ?? {}),\n      toolExecution,\n    };\n    metadata.openpond = openpond;\n  }\n\n  return Object.keys(metadata).length > 0 ? metadata : undefined;\n}\n\nasync function safeParseJson(response: Response): Promise<unknown> {\n  const contentType = response.headers.get(\"content-type\");\n  if (!contentType || !contentType.includes(\"application/json\")) {\n    return undefined;\n  }\n\n  try {\n    return await response.json();\n  } catch (error) {\n    return { error: \"Failed to parse error body\", cause: String(error) };\n  }\n}\n\nfunction isPrimaryChoice(choice: ChatCompletionChoice): boolean {\n  return choice.index === 0 || choice.message !== undefined;\n}\n\nfunction toAbortError(reason: unknown): AIAbortError {\n  if (reason instanceof AIAbortError) {\n    return reason;\n  }\n\n  if (reason instanceof Error) {\n    if (reason.name === \"AbortError\") {\n      return new AIAbortError(reason.message || \"AI request aborted\");\n    }\n    return new AIAbortError(reason.message);\n  }\n\n  return new AIAbortError(String(reason ?? \"AI request aborted\"));\n}\n\nexport { listModels };\n"]}